<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Build-a-Plate</title>
<style>
  body{font-family:Arial;margin:18px}
  #top{display:flex;gap:20px;align-items:flex-start}
  #palette{width:360px;border:1px solid #ddd;padding:14px;border-radius:8px}
  .food{display:flex;align-items:center;gap:12px;padding:10px;border-radius:8px;margin-bottom:10px;background:#fafafa;cursor:grab;font-size:15px}
  .food img{width:64px;height:64px;object-fit:cover;border-radius:8px}
  #platecard{width:820px;height:520px;border:1px solid #ddd;border-radius:8px;position:relative;background:linear-gradient(#fff,#f6f6f6);padding:22px;box-sizing:border-box;overflow:visible}
  #plateWrapper{position:relative;width:520px;height:520px;margin:0 auto}
  #plate{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:480px;
    height:480px;
    border-radius:50%;
    background:#fff6e6;
    border:8px solid #eee;
    box-shadow:0 2px 6px rgba(0,0,0,0.08);
    overflow:visible;
    display:block;
  } 
  #controls{margin-top:12px}
  button{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#fff;cursor:pointer}
  #summary{margin-top:10px}
  .small{font-size:13px;color:#555}
  .side-placed{position:absolute}
  #platecard { overflow: visible; }
  .food:active { cursor:grabbing; }
  @media (max-width:900px){ #top{flex-direction:column} #platecard{width:100%;} #palette{width:100%;} }
  .placed { object-fit:cover; }
  #payloadBox { white-space:pre-wrap; font-family:monospace; border:1px dashed #ccc; padding:10px; margin-top:10px; display:none; max-height:220px; overflow:auto; background:#fafafa }
  #submitStatus { margin-top:8px; font-size:13px; color:#333 }
</style>
</head>
<body>
  <h3>Build a Plate — click to add</h3>
  <div id="top">
    <div id="palette">
      <strong>Food palette</strong>
      <div class="small">Click an item to add one portion.</div>
      <div id="foods" style="margin-top:8px"></div>
    </div>

    <div id="platecard">
      <div id="plateWrapper">
        <div id="plate"></div>
      </div>
    </div>
  </div>

  <div id="controls">
    <label>Name (optional) <input id="name" type="text"/></label>
    <button id="clear">Clear plate</button>
    <button id="submit">Submit plate</button>
    <div id="submitStatus"></div>
    <div id="payloadBox"></div>
    <div id="summary"></div>
  </div>

<script>
window.addEventListener('DOMContentLoaded', () => {

//  CONFIG   
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbxEpMGjGgkn8a7_RG0-fSyPj-IZny88ZChcqtQ_ks1ALOv0bxrKYTmLy8pSjx0A5euX5A/exec';

//  CATALOG & LAYOUT  
const FOOD_CATALOG = [
  {id:'potato', label:'Potato', kcal:160, img:'images/potato.svg', placement:'onplate'},
  {id:'sausage', label:'Sausage', kcal:250, img:'images/sausage.svg', placement:'onplate'},
  {id:'carrot', label:'Carrot', kcal:25, img:'images/carrot.svg', placement:'onplate'},
  {id:'bread', label:'Bread slice', kcal:80, img:'images/slice-of-bread.svg', placement:'side', hasOptions:true},
  {id:'bread_butter', label:'Bread with butter', kcal:80 + 102, img:'images/bread-with-butter.svg', placement:'side', hidden:true},
  {id:'bread_butter_cheese', label:'Bread with butter and cheese', kcal:80 + 102 + 110, img:'images/cheese-bread.svg', placement:'side', hidden:true},
  {id:'cheese', label:'Cheese', kcal:110, img:'images/cheese.svg', placement:'onplate', hidden:true},
  {id:'butter', label:'Butter', kcal:102, img:'images/butter.svg', placement:'onplate', hidden:true},
  {id:'apple', label:'Apple', kcal:95, img:'images/apple.svg', placement:'side'},
  {id:'water', label:'Water (glass)', kcal:0, img:'images/glass-of-water.svg', placement:'side'},
  {id:'milk', label:'Milk (carton)', kcal:150, img:'images/milk-carton.svg', placement:'side'}
];

const PLATE_DIAMETER = 480;
const SIZE_MAP = {
  potato: 100,
  sausage: 125,
  carrot: 44,
  bread: 72,
  bread_butter: 72,
  bread_butter_cheese: 72,
  cheese: 54,
  butter: 36,
  apple: 86,
  water: 62,
  milk: 62
};
const SIDE_SLOT_GAP_PX = 38;
const OVERLAP_FACTOR = 0.88;

const state = { placedInstances: [] }; // {id,label,kcal,x,y,sizePx,rotationDeg,placement,sideSlot}

// Expose for debugging in DevTools
window.state = state;
window.addInstanceToPlate = addInstanceToPlate;
window.renderPlate = renderPlate;
window.updateSummary = updateSummary;

//  HELPERS   
function catalogFind(id){ return FOOD_CATALOG.find(it=>it.id===id); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }

function collidesWithOnPlate(candidate) {
  for(const inst of state.placedInstances) {
    if(inst.placement !== 'onplate') continue;
    const minDist = (candidate.sizePx/2 + inst.sizePx/2) * OVERLAP_FACTOR;
    if(dist(candidate, inst) < minDist) return true;
  }
  const cx = PLATE_DIAMETER/2, cy = PLATE_DIAMETER/2;
  const dx = candidate.x - cx, dy = candidate.y - cy;
  const radius = PLATE_DIAMETER/2 - Math.max(8, candidate.sizePx/2);
  if(Math.sqrt(dx*dx + dy*dy) > radius) return true;
  return false;
}

//  UI BUILD   
const foodsDiv = document.getElementById('foods');
if (!foodsDiv) {
  console.error('foodsDiv element not found. Did DOMContentLoaded run?');
}
console.log('FOOD_CATALOG items count:', FOOD_CATALOG.length);
foodsDiv.innerHTML = '';

function makeFoodTile(item) {
  const el = document.createElement('div');
  el.className = 'food';
  el.dataset.id = item.id;
  el.setAttribute('draggable','true');
  el.innerHTML = `<img src="${item.img}" alt="${item.label}"><div><strong>${item.label}</strong><div class="small">${item.kcal} kcal/portion</div></div>`;
  return el;
}

FOOD_CATALOG.forEach(item => {
  if(item.hidden) return;
  const tile = makeFoodTile(item);

  tile.addEventListener('dragstart', (ev) => {
    ev.dataTransfer.setData('text/plain', tile.dataset.id || '');
    try { ev.dataTransfer.setDragImage(tile.querySelector('img'), 24, 24); } catch(e){}
  });

  if(item.hasOptions) {
    const opts = document.createElement('div');
    opts.style.marginTop = '6px';
    opts.innerHTML = `
      <button data-action="addSlice" style="padding:4px 8px;border-radius:4px;margin-right:6px">Add slice</button>
      <button data-action="addButter" style="padding:4px 8px;border-radius:4px;margin-right:6px">Add butter</button>
      <button data-action="addCheese" style="padding:4px 8px;border-radius:4px" disabled>Add cheese</button>
    `;
    tile.appendChild(opts);

    const btnAddSlice = opts.querySelector('button[data-action="addSlice"]');
    const btnAddButter = opts.querySelector('button[data-action="addButter"]');
    const btnAddCheese = opts.querySelector('button[data-action="addCheese"]');

    tile.addEventListener('click', (ev) => {
      if (ev.target.closest('button')) return;
      addInstanceToPlate('bread', 1, {});
    });

    btnAddSlice.addEventListener('click', (ev) => { ev.stopPropagation(); addInstanceToPlate('bread', 1, {}); });

    btnAddButter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const idxPlain = state.placedInstances.findIndex(p => p.id === 'bread' && p.placement === 'side');
      if(idxPlain >= 0) {
        const prev = state.placedInstances[idxPlain];
        const slot = prev.sideSlot;
        state.placedInstances.splice(idxPlain, 1, {
          id: 'bread_butter',
          label: catalogFind('bread_butter').label,
          kcal: catalogFind('bread_butter').kcal,
          x: prev.x, y: prev.y,
          sizePx: SIZE_MAP['bread_butter'],
          rotationDeg: 0, placement: 'side', sideSlot: slot
        });
      } else {
        addInstanceToPlate('bread_butter', 1, {});
      }
      btnAddCheese.disabled = !state.placedInstances.some(p => p.id === 'bread_butter');
      renderPlate(); updateSummary();
    });

    btnAddCheese.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const idxButter = state.placedInstances.findIndex(p => p.id === 'bread_butter' && p.placement === 'side');
      if(idxButter >= 0) {
        const prev = state.placedInstances[idxButter];
        const slot = prev.sideSlot;
        state.placedInstances.splice(idxButter, 1, {
          id: 'bread_butter_cheese',
          label: catalogFind('bread_butter_cheese').label,
          kcal: catalogFind('bread_butter_cheese').kcal,
          x: prev.x, y: prev.y,
          sizePx: SIZE_MAP['bread_butter_cheese'],
          rotationDeg: 0, placement: 'side', sideSlot: slot
        });
      }
      btnAddCheese.disabled = !state.placedInstances.some(p => p.id === 'bread_butter');
      renderPlate(); updateSummary();
    });

    btnAddCheese.disabled = !state.placedInstances.some(p => p.id === 'bread_butter');

  } else {
    tile.addEventListener('click', (ev)=>{
      const add = ev.shiftKey ? 3 : 1;
      addInstanceToPlate(item.id, add, {});
    });
  }

  foodsDiv.appendChild(tile);
});

if (!foodsDiv.childElementCount) {
  foodsDiv.innerHTML = '<div style="padding:12px;color:#666">No food options available. Check console for errors.</div>';
  console.warn('No food tiles rendered. Check for JS errors or missing images.');
}

//  SIDE SLOTS   
function computeSideSlots() {
  const plateCard = document.getElementById('platecard');
  const plateEl = document.getElementById('plate');
  const cardRect = plateCard.getBoundingClientRect();
  const plateRect = plateEl.getBoundingClientRect();
  const plateRightInCard = plateRect.right - cardRect.left;
  const gap = Math.max(8, Math.round(PLATE_DIAMETER * 0.02));
  const columnX = Math.min(plateCard.clientWidth - 30, Math.round(plateRightInCard + gap));
  const slotStartY = 40;
  const slotSpacing = SIDE_SLOT_GAP_PX;
  const slotBaseHeight = 40;
  const availableHeight = plateCard.clientHeight - slotStartY - 20;
  const slotStep = slotBaseHeight + slotSpacing;
  const maxSlots = Math.max(4, Math.floor(availableHeight / slotStep));
  const slots = [];
  for(let i=0;i<maxSlots;i++){
    slots.push({ x: columnX, y: slotStartY + i * slotStep });
  }
  return slots;
}
function reserveSideSlot() {
  const slots = computeSideSlots();
  const occupied = new Set(state.placedInstances.filter(p=>p.placement==='side' && typeof p.sideSlot === 'number').map(p=>p.sideSlot));
  for(let i=0;i<slots.length;i++) if(!occupied.has(i)) return i;
  return slots.length;
}

//  ADD with overlap avoidance   
function addInstanceToPlate(id, count=1, options={}) {
  const item = catalogFind(id); if(!item) { console.warn('Unknown catalog id', id); return; }
  for(let i=0;i<count;i++){
    const sizePx = SIZE_MAP[id] || SIZE_MAP[item.id] || Math.round(PLATE_DIAMETER * 0.10);
    const rotationDeg = (item.placement === 'onplate') ? (Math.random()*34 - 17) : 0;
    let x,y, sideSlot;
    if(item.placement === 'onplate') {
      const cx = PLATE_DIAMETER/2, cy = PLATE_DIAMETER/2, rMin = 30;
      const rMax = PLATE_DIAMETER/2 - sizePx/2 - 8;
      let attempts=0, candidate;
      const maxAttempts = 60;
      do {
        const angle = Math.random() * Math.PI * 2;
        const radius = rMin + Math.random() * Math.max(0, rMax - rMin);
        candidate = { x: Math.round(cx + Math.cos(angle) * radius), y: Math.round(cy + Math.sin(angle) * radius), sizePx };
        attempts++;
      } while(collidesWithOnPlate(candidate) && attempts < maxAttempts);
      x = candidate.x; y = candidate.y;
    } else {
      sideSlot = reserveSideSlot();
      const slots = computeSideSlots();
      const chosenSlot = slots[Math.min(sideSlot, slots.length-1)];
      x = chosenSlot.x; y = chosenSlot.y + Math.round(sizePx/2);
    }
    state.placedInstances.push({ id: item.id, label: item.label, kcal: item.kcal, x, y, sizePx, rotationDeg, placement: item.placement, sideSlot: (typeof sideSlot==='number'?sideSlot:undefined) });
  }
  renderPlate(); updateSummary();
}

//  RENDER   
const plateEl = document.getElementById('plate');
const plateCard = document.getElementById('platecard');

function renderPlate(){
  plateEl.innerHTML = '';
  Array.from(plateCard.querySelectorAll('.side-placed')).forEach(n=>n.remove());
  plateEl.style.width = PLATE_DIAMETER + 'px'; plateEl.style.height = PLATE_DIAMETER + 'px';
  const slots = computeSideSlots();
  state.placedInstances.forEach((inst, idx) => {
    const catalogItem = catalogFind(inst.id) || {};
    const img = document.createElement('img');
    img.src = catalogItem.img || ('images/' + inst.id + '.svg');
    img.alt = inst.label || inst.id; img.className = 'placed';
    img.style.width = inst.sizePx + 'px'; img.style.height = inst.sizePx + 'px';
    img.style.pointerEvents = 'auto'; img.style.transition = 'transform 120ms ease-out';
    img.style.zIndex = 10 + idx; img.title = `${inst.label} — ${inst.kcal} kcal`;
    if(inst.placement === 'onplate') {
      img.style.left = inst.x + 'px'; img.style.top = inst.y + 'px';
      img.style.transform = `translate(-50%,-50%) rotate(${inst.rotationDeg}deg)`;
      img.addEventListener('click', ()=> { state.placedInstances.splice(idx,1); renderPlate(); updateSummary(); });
      plateEl.appendChild(img);
    } else {
      img.classList.add('side-placed'); img.style.position = 'absolute';
      const slotIndex = (typeof inst.sideSlot === 'number') ? inst.sideSlot : reserveSideSlot();
      const chosenSlot = slots[Math.min(slotIndex, slots.length-1)];
      const left = Math.min(Math.max(chosenSlot.x, 10), plateCard.clientWidth - 10);
      const top = Math.min(Math.max(chosenSlot.y + Math.round((inst.sizePx||40)/2), 10), plateCard.clientHeight - 10);
      img.style.left = left + 'px'; img.style.top = top + 'px'; img.style.transform = 'translate(-50%,-50%)';
      img.addEventListener('click', ()=> { state.placedInstances.splice(idx,1); renderPlate(); updateSummary(); });
      plateCard.appendChild(img);
    }
  });
  updateSummary();
}

//  SUMMARY / CLEAR   
function updateSummary() {
  const sumDiv = document.getElementById('summary');
  if(state.placedInstances.length === 0) { sumDiv.innerHTML = '<div class="small">Plate is empty</div>'; return; }
  const agg = {}; let totalKcal = 0;
  state.placedInstances.forEach(it=>{ agg[it.id] = agg[it.id] || {label: it.label, count:0, kcal: it.kcal}; agg[it.id].count++; totalKcal += it.kcal; });
  let html = `<div><strong>Total kcal:</strong> ${totalKcal}</div>`;
  html += '<div class="small" style="margin-top:6px"><strong>Contents</strong></div>';
  html += '<ul class="small" style="margin:6px 0 0 18px;padding:0">';
  Object.values(agg).forEach(a=>{ html += `<li>${a.label}: ${a.count} portion${a.count>1?'s':''} (${a.kcal} kcal each)</li>`; });
  html += '</ul>';
  sumDiv.innerHTML = html;
}

  // ---------------------- Part B: Session save + Comparison UI ----------------------

// Add Save Session and Comparison UI elements dynamically for convenience
(function addComparisonControls() {
  const controls = document.getElementById('controls');
  if (!controls) return;

  // Save session row
  const openBtn = document.createElement('button');
  openBtn.id = 'openComparisons';
  openBtn.textContent = 'Open comparisons';
  openBtn.style.marginBottom = '10px';
  controls.insertBefore(openBtn, controls.firstChild);

  // Comparison panel
  const compPanel = document.createElement('div');
  compPanel.style.marginTop = '10px';
  compPanel.innerHTML = `
    <strong>Comparisons</strong>
    <div style="margin-top:6px">
      <button id="cmpRecommended">Compare to Recommended</button>
      <button id="cmpPast">Compare to Past Session</button>
      <select id="pastSessionsSelect" style="margin-left:6px"></select>
    </div>
    <div style="margin-top:8px">
      <button id="cmpReality" title="Compare to a specific reality session (pick from Past sessions)">Compare to Reality</button>
    </div>
  `;
  controls.appendChild(compPanel);

  // Pre-fill past sessions select
  refreshPastSessionsList();
})();

// Helper: send payload via form-encoded POST
async function postPayload(payloadObj) {
  const form = new URLSearchParams();
  form.append('payload', JSON.stringify(payloadObj));
  const res = await fetch(WEB_APP_URL, { method: 'POST', body: form });
  if (!res.ok) throw new Error('Server returned ' + res.status);
  const json = await res.json().catch(()=>null);
  return json;
}
// helper that posts payload and returns server json
async function postPayloadForm(payloadObj) {
  const form = new URLSearchParams();
  form.append('payload', JSON.stringify(payloadObj));
  const res = await fetch(WEB_APP_URL, { method: 'POST', body: form });
  const json = await res.json().catch(()=>null);
  return json;
}

// auto-save + navigate to compare page
document.getElementById('openComparisons').addEventListener('click', async () => {
  if (!state.placedInstances || state.placedInstances.length === 0) { alert('Build the plate first'); return; }
  const label = 'Session ' + (new Date()).toLocaleString();
  // payload includes positions so the compare page can anchor items exactly
  const payload = {
    name: 'presenter',
    timestamp: new Date().toISOString(),
    sessionLabel: label,
    items: state.placedInstances.map(it=>({ id: it.id, label: it.label, count: 1, kcal: it.kcal || 0 })),
    positions: state.placedInstances.map(it=>({ id: it.id, x: it.x, y: it.y, sizePx: it.sizePx, rotationDeg: it.rotationDeg, placement: it.placement, sideSlot: it.sideSlot }))
  };
  try {
    const resp = await postPayloadForm(payload); // form-encoded -> avoids preflight
    if (!resp) { alert('Save failed'); return; }
    // server returns sessionId if saved as session
    const sessionId = resp.sessionId || resp.sessionId || resp.sessionId;
    // fallback: if server didn't send id, still open compare page and pass positions via sessionStorage
    if (sessionId) {
      // navigate with session id
      window.location.href = 'compare.html?sessionId=' + encodeURIComponent(sessionId);
    } else {
      // fallback: save positions into sessionStorage and navigate without id
      sessionStorage.setItem('plate_positions_fallback', JSON.stringify(payload));
      window.location.href = 'compare.html';
    }
  } catch (err) {
    console.error('Auto-save failed', err);
    alert('Auto-save failed; see console');
  }
});

// Save session handler
document.addEventListener('click', (ev) => {
  if (!ev.target) return;
  if (ev.target.id === 'saveSessionBtn') {
    const label = document.getElementById('sessionLabel').value.trim() || ('Session ' + new Date().toLocaleString());
    if (state.placedInstances.length === 0) { alert('Nothing on plate to save'); return; }
    const payload = {
      name: 'presenter',
      timestamp: new Date().toISOString(),
      sessionLabel: label,
      items: state.placedInstances.map(it => ({ id: it.id, label: it.label, count: 1, kcal: it.kcal || 0 })),
      // include positions so sessions can be replayed exactly: positions per placed instance
      positions: state.placedInstances.map(it => ({ id: it.id, x: it.x, y: it.y, sizePx: it.sizePx, rotationDeg: it.rotationDeg, placement: it.placement, sideSlot: it.sideSlot }))
    };
    const statusEl = document.getElementById('saveSessionStatus');
    statusEl.textContent = 'Saving...';
    postPayload(payload).then(resp => {
      if (resp && resp.status === 'ok') {
        statusEl.textContent = 'Saved';
      } else if (resp && resp.sessionId) {
        statusEl.textContent = 'Saved (id:' + resp.sessionId + ')';
      } else {
        statusEl.textContent = 'Saved';
      }
      setTimeout(()=>{ statusEl.textContent = ''; refreshPastSessionsList(); }, 1200);
    }).catch(err => {
      console.error('Save session failed', err);
      statusEl.textContent = 'Error saving';
      setTimeout(()=>{ statusEl.textContent = ''; }, 2000);
    });
  }
});

// Fetch past sessions list and populate select
async function refreshPastSessionsList() {
  try {
    const url = WEB_APP_URL + '?mode=sessions';
    const res = await fetch(url);
    if (!res.ok) { console.warn('sessions fetch failed', res.status); return; }
    const json = await res.json().catch(()=>null);
    const sel = document.getElementById('pastSessionsSelect');
    if (!sel) return;
    sel.innerHTML = '';
    if (json && json.sessions && json.sessions.length) {
      json.sessions.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.sessionId;
        opt.textContent = `${s.label || s.sessionId} — ${s.timestamp || ''} (${s.kcalTotal || 0} kcal)`;
        sel.appendChild(opt);
      });
    } else {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'No sessions saved';
      sel.appendChild(opt);
    }
  } catch (err) {
    console.error('refreshPastSessionsList error', err);
  }
}

// Comparison flow: fetch target (recommended or session) and animate
async function compareToTarget(targetPayload, options = {}) {
  // options: { title: 'Recommended', anchorPositions: state.placedInstances positions if available, animateDurationMs: 800 }
  const animateMs = options.animateDurationMs || 800;
  const anchorPositions = (options.anchorPositions && options.anchorPositions.length) ? options.anchorPositions : state.placedInstances;
  if (!anchorPositions || anchorPositions.length === 0) { alert('No base plate (Estimate) saved to anchor comparisons. Build plate first.'); return; }

  // Build maps of counts for anchor (estimate) and target
  const anchorCounts = {}; // id -> count in anchor
  anchorPositions.forEach(it => { anchorCounts[it.id] = (anchorCounts[it.id] || 0) + 1; });

  const targetCounts = {}; // id -> count
  if (targetPayload.items && Array.isArray(targetPayload.items)) {
    targetPayload.items.forEach(it => { targetCounts[it.id] = (targetCounts[it.id] || 0) + (it.count || 1); });
  } else if (targetPayload.itemsMap) {
    Object.assign(targetCounts, targetPayload.itemsMap);
  }

  // build overlay container
  const plateCardRect = plateCard.getBoundingClientRect();
  const overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.left = plateCardRect.left + 'px';
  overlay.style.top = plateCardRect.top + 'px';
  overlay.style.width = plateCardRect.width + 'px';
  overlay.style.height = plateCardRect.height + 'px';
  overlay.style.pointerEvents = 'none';
  overlay.style.zIndex = 2000;
  document.body.appendChild(overlay);


  // do not gray by default — gray only when we animate the overlay
// when starting animation, we'll set these styles

  // For each anchor position, create an overlay image and compute its target scale
  const maxScale = 2.4;
  const minScale = 0.3;
  const created = [];
  anchorPositions.forEach((anchor, i) => {
    // find anchor count and compute target count for this id
    const id = anchor.id;
    const anchorCount = anchorCounts[id] || 1;
    const tgtCount = Math.max(0, targetCounts[id] || 0);
    // scale by ratio of counts; area-based scale -> use sqrt of ratio
    const ratio = (anchorCount === 0) ? (tgtCount > 0 ? (tgtCount) : 0) : (tgtCount / anchorCount);
    let scale = Math.sqrt(Math.max(0.0001, ratio));
    if (!isFinite(scale) || scale <= 0) scale = 0.01;
    scale = Math.min(maxScale, Math.max(minScale, scale));

    // position overlayed image at the same absolute position
    const img = document.createElement('img');
    const catalogItem = catalogFind(id) || {};
    img.src = catalogItem.img || ('images/' + id + '.svg');
    img.style.position = 'absolute';
    // absolute coords relative to document:
    const plateRect = plateCard.getBoundingClientRect();
    const absX = plateRect.left + anchor.x;
    const absY = plateRect.top + anchor.y;
    img.style.left = absX + 'px';
    img.style.top = absY + 'px';
    img.style.width = (anchor.sizePx || 40) + 'px';
    img.style.height = (anchor.sizePx || 40) + 'px';
    img.style.transform = 'translate(-50%,-50%) scale(0.001)';
    img.style.transition = `transform ${animateMs}ms cubic-bezier(.2,.9,.2,1), opacity ${animateMs}ms ease`;
    img.style.opacity = '0.0';
    img.style.pointerEvents = 'none';
    overlay.appendChild(img);
    created.push({ img, scale, id, anchor });
  });

  // apply gray-out just before animating so the base stays normal initially
  plateCard.style.transition = 'filter 300ms ease, opacity 300ms ease';
  plateCard.style.filter = 'grayscale(1)';
  plateCard.style.opacity = '0.45';
  // Force reflow then animate
  requestAnimationFrame(() => {
    created.forEach(c => {
      c.img.style.opacity = '1';
      c.img.style.transform = `translate(-50%,-50%) scale(${c.scale})`;
    });
  });

  // After animation, show small textual summary
  setTimeout(() => {
    // compute a short diff summary: top changed items
    const diffs = [];
    const allIds = new Set([...Object.keys(anchorCounts), ...Object.keys(targetCounts)]);
    allIds.forEach(id => {
      const a = anchorCounts[id] || 0;
      const t = targetCounts[id] || 0;
      if (a === t) return;
      const pct = a === 0 ? 100 : Math.round(((t - a) / a) * 100);
      diffs.push({ id, a, t, pct });
    });
    diffs.sort((x,y) => Math.abs(y.pct) - Math.abs(x.pct));
    const top = diffs.slice(0,5).map(d => `${d.id}: ${d.a}→${d.t} (${d.pct>0?'+':''}${d.pct}%)`);
    // show overlay caption
    const caption = document.createElement('div');
    caption.style.position = 'fixed';
    caption.style.left = '50%';
    caption.style.bottom = '20px';
    caption.style.transform = 'translateX(-50%)';
    caption.style.background = 'rgba(0,0,0,0.75)';
    caption.style.color = '#fff';
    caption.style.padding = '8px 12px';
    caption.style.borderRadius = '6px';
    caption.style.zIndex = 2010;
    caption.style.fontSize = '13px';
    caption.textContent = (options.title ? options.title + ': ' : '') + (top.length ? top.join('; ') : 'No changes');
    document.body.appendChild(caption);

    // cleanup after a delay
    setTimeout(() => {
      document.body.removeChild(caption);
      document.body.removeChild(overlay);
      plateCard.style.filter = '';
      plateCard.style.opacity = '';
      // also refresh sessions list in case we saved during this presentation
      refreshPastSessionsList();
      if (options.onComplete) options.onComplete();
    }, 2400);
  }, animateMs + 80);
}

// Wire comparison buttons
document.getElementById('cmpRecommended').addEventListener('click', async () => {
  try {
    const url = WEB_APP_URL + '?mode=summary';
    const res = await fetch(url);
    if (!res.ok) { alert('Failed to fetch recommended'); return; }
    const json = await res.json();
    // convert recommended items to standard payload shape: items: [{id,label,count,kcal}]
    const items = (json.items || []).map(it => {
    const avg = (it.avgPerSubmission !== undefined && it.avgPerSubmission !== null) ? Number(it.avgPerSubmission) : (it.totalCount || 0);
    const count = avg > 0 && avg < 1 ? 1 : Math.round(avg);
    return { id: it.id, label: it.label, count, kcal: it.totalKcal ? Math.round(it.totalKcal / Math.max(1, it.totalCount)) : 0 };
  });
    const targetPayload = { items };
    compareToTarget(targetPayload, { title: 'Recommended vs Estimate', anchorPositions: state.placedInstances });
  } catch (err) {
    console.error(err);
    alert('Error fetching recommended data. Check console.');
  }
});

document.getElementById('cmpPast').addEventListener('click', async () => {
  const sel = document.getElementById('pastSessionsSelect');
  if (!sel || !sel.value) { alert('No saved session selected'); return; }
  const sessionId = sel.value;
  try {
    const url = WEB_APP_URL + '?mode=session&sessionId=' + encodeURIComponent(sessionId);
    const res = await fetch(url);
    if (!res.ok) { alert('Failed to fetch session'); return; }
    const json = await res.json();
    if (json && json.payload) {
      const payload = json.payload;
      compareToTarget(payload, { title: 'Past session vs Estimate', anchorPositions: state.placedInstances });
    } else {
      alert('Session payload missing');
    }
  } catch (err) {
    console.error(err);
    alert('Error fetching session. Check console.');
  }
});

// For "Reality" allow selecting from past sessions as well; reuse cmpPast or you can implement a special mapping
document.getElementById('cmpReality').addEventListener('click', async () => {
  // for now reuse selected past session as reality; you may adapt to load a predefined reality session id
  const sel = document.getElementById('pastSessionsSelect');
  if (!sel || !sel.value) { alert('No saved session selected to use as Reality'); return; }
  const sessionId = sel.value;
  try {
    const url = WEB_APP_URL + '?mode=session&sessionId=' + encodeURIComponent(sessionId);
    const res = await fetch(url);
    const json = await res.json();
    if (json && json.payload) {
      compareToTarget(json.payload, { title: 'Reality vs Estimate', anchorPositions: state.placedInstances });
    } else {
      alert('Session payload missing');
    }
  } catch (err) {
    console.error(err);
    alert('Error fetching reality session');
  }
});

document.getElementById('clear').addEventListener('click', ()=>{ state.placedInstances = []; renderPlate(); updateSummary(); });

// Submit: send form-encoded payload ( alerts for success/failure)
const submitStatus = document.getElementById('submitStatus'); // ensure this element exists in your HTML
// Submit: background POST (form-encoded), simple alerts for success/failure
document.getElementById('submit').addEventListener('click', async () => {
  const nameEl = document.getElementById('name');
  const name = nameEl ? nameEl.value.trim() : '';

  if (state.placedInstances.length === 0) {
    alert('Plate is empty. Add items before submitting.');
    return;
  }

  // build payload
  const agg = {};
  state.placedInstances.forEach(it => {
    agg[it.id] = agg[it.id] || { id: it.id, label: it.label, kcal: it.kcal, count: 0 };
    agg[it.id].count++;
  });
  const items = Object.values(agg);
  const kcalTotal = items.reduce((s, it) => s + it.kcal * it.count, 0);
  const payloadObj = { name: name || 'anonymous', timestamp: new Date().toISOString(), items, kcalTotal };
  const payloadJson = JSON.stringify(payloadObj);

  // Validate WEB_APP_URL using a strict exec-URL pattern
  const validExec = /^https:\/\/script\.google\.com\/macros\/s\/[A-Za-z0-9_-]+\/exec$/;
  if (!WEB_APP_URL || !validExec.test(WEB_APP_URL)) {
    console.log('Invalid WEB_APP_URL detected:', WEB_APP_URL);
    alert('Server URL not configured or invalid. Open DevTools Console to see the current WEB_APP_URL.');
    return;
  }

  try {
    const form = new URLSearchParams();
    form.append('payload', payloadJson);

    const res = await fetch(WEB_APP_URL, { method: 'POST', body: form });

    if (!res.ok) {
      const txt = await res.text().catch(()=>res.statusText || '');
      console.error('Submit failed', res.status, txt);
      alert('Submit failed: ' + (txt || res.status));
      return;
    }

    const json = await res.json().catch(()=>null);
    if (json && json.status === 'ok') {
      alert('Submission successful');
      state.placedInstances = [];
      renderPlate();
      updateSummary();
    } else {
      console.warn('Submit returned unexpected response', json);
      alert('Submission returned an unexpected response; check console.');
    }
  } catch (err) {
    console.error('Submit error', err);
    alert('Network error while submitting. Check console for details.');
  }
});

//  Drag & Drop   
plateEl.addEventListener('dragover', (e) => { e.preventDefault(); });
plateEl.addEventListener('drop', (e) => {
  e.preventDefault();
  const id = e.dataTransfer.getData('text/plain'); if(!id) return;
  const item = catalogFind(id); if(!item) return;
  const rect = plateEl.getBoundingClientRect();
  const localX = e.clientX - rect.left; const localY = e.clientY - rect.top;
  if(item.placement === 'onplate') {
    const sizePx = SIZE_MAP[id] || SIZE_MAP[item.id] || Math.round(PLATE_DIAMETER * 0.10);
    const candidate = { x: Math.min(Math.max(Math.round(localX), 10), PLATE_DIAMETER - 10), y: Math.min(Math.max(Math.round(localY), 10), PLATE_DIAMETER - 10), sizePx };
    let placed = false;
    if(!collidesWithOnPlate(candidate)) {
      state.placedInstances.push({ id:item.id, label:item.label, kcal:item.kcal, x:candidate.x, y:candidate.y, sizePx, rotationDeg:(Math.random()*34 - 17), placement:item.placement });
      placed = true;
    } else {
      const maxAttempts = 30;
      for(let a=0;a<maxAttempts && !placed;a++){
        const ang = Math.random()*Math.PI*2;
        const rad = 10 + a * 6;
        const cx = candidate.x + Math.round(Math.cos(ang)*rad);
        const cy = candidate.y + Math.round(Math.sin(ang)*rad);
        const cand = { x: cx, y: cy, sizePx };
        if(!collidesWithOnPlate(cand)) {
          state.placedInstances.push({ id:item.id, label:item.label, kcal:item.kcal, x:cand.x, y:cand.y, sizePx, rotationDeg:(Math.random()*34 - 17), placement:item.placement });
          placed = true;
        }
      }
    }
    if(!placed) addInstanceToPlate(item.id, 1, {});
    else { renderPlate(); updateSummary(); }
  } else {
    const cardRect = plateCard.getBoundingClientRect();
    const localYcard = e.clientY - cardRect.top;
    const slots = computeSideSlots();
    let nearest = 0, minD = Infinity;
    for(let i=0;i<slots.length;i++){
      const d = Math.abs(localYcard - slots[i].y);
      if(d < minD){ minD = d; nearest = i; }
    }
    const sizePx = SIZE_MAP[id] || SIZE_MAP[item.id] || Math.round(PLATE_DIAMETER * 0.09);
    state.placedInstances.push({ id:item.id, label:item.label, kcal:item.kcal, x: slots[Math.min(nearest, slots.length-1)].x, y: slots[Math.min(nearest, slots.length-1)].y + Math.round(sizePx/2), sizePx, rotationDeg:0, placement:'side', sideSlot:nearest });
    renderPlate(); updateSummary();
  }
});

plateCard.addEventListener('dragover', (e) => { e.preventDefault(); });
plateCard.addEventListener('drop', (e) => {
  e.preventDefault();
  const id = e.dataTransfer.getData('text/plain'); if(!id) return;
  const item = catalogFind(id); if(!item) return;
  const plateRect = plateEl.getBoundingClientRect();
  if(e.clientX >= plateRect.left && e.clientX <= plateRect.right && e.clientY >= plateRect.top && e.clientY <= plateRect.bottom) {
    const ev = new DragEvent('drop', { bubbles: true, cancelable: true, clientX: e.clientX, clientY: e.clientY, dataTransfer: e.dataTransfer });
    plateEl.dispatchEvent(ev);
    return;
  }
  const cardRect = plateCard.getBoundingClientRect();
  const localYcard = e.clientY - cardRect.top;
  const slots = computeSideSlots();
  let nearest = 0, minD = Infinity;
  for(let i=0;i<slots.length;i++){
    const d = Math.abs(localYcard - slots[i].y);
    if(d < minD){ minD = d; nearest = i; }
  }
  const sizePx = SIZE_MAP[id] || SIZE_MAP[item.id] || Math.round(PLATE_DIAMETER * 0.09);
  state.placedInstances.push({ id:item.id, label:item.label, kcal:item.kcal, x: slots[Math.min(nearest, slots.length-1)].x, y: slots[Math.min(nearest, slots.length-1)].y + Math.round(sizePx/2), sizePx, rotationDeg:0, placement:'side', sideSlot:nearest });
  renderPlate(); updateSummary();
});

// initial
renderPlate(); updateSummary();
});
</script>
</body>

</html>






