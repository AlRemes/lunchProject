<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Compare Plate — whole plate scale (fixed)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body{font-family:Arial;margin:14px;background:#f6f6f7}
  .topbar{display:flex;gap:12px;align-items:center;justify-content:center;margin-bottom:10px}
  .btn{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#fff;cursor:pointer}
  #stage{position:relative;width:980px;height:660px;margin:6px auto;border-radius:8px;background:#fff;padding:16px;box-shadow:0 6px 22px rgba(0,0,0,0.08)}
  #plateWrap{position:relative;width:720px;height:640px;margin:0 auto}
  /* plateCanvas contains two stacked layers:
     - baseLayer: gray template showing full saved scene (plate, on-plate items and side items)
     - overlayLayer: colored plate circle + only on-plate items; this is what we scale as a single unit */
  #plateCanvas{position:relative;width:520px;height:520px;border-radius:50%;background:#fff6e6;border:8px solid #eee;overflow:visible;margin:10px auto}
  #plateCanvas .layer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
  #baseLayer{z-index:0; transform-origin:50% 50%;}
  #overlayLayer{z-index:2; transform-origin:50% 50%; transform:scale(0.92);} /* initial slightly smaller */
  .plateCircle { position:absolute; left:50%; top:50%; width:88%; height:88%; transform:translate(-50%,-50%); border-radius:50%; background:transparent; }
  .baseItemWrapper, .overlayItemWrapper{position:absolute; transform:translate(-50%,-50%); pointer-events:none;}
  .baseItemWrapper img, .overlayItemWrapper img{display:block;width:100%;height:100%;object-fit:contain}
  .clip-half { -webkit-clip-path: polygon(0 0, 100% 100%, 0 100%); clip-path: polygon(0 0, 100% 100%, 0 100%); }
  #caption{margin-top:12px;text-align:center;font-size:14px}
  .small{font-size:13px;color:#444}
</style>
</head>
<body>
  <div class="topbar">
    <button id="backBtn" class="btn">Back</button>
    <button id="cmpRecommendedBtn" class="btn">Compare to Recommended (Finland)</button>
    <button id="cmpRealityBtn" class="btn">Compare to Reality (custom)</button>
    <div id="status" class="small" style="margin-left:8px"></div>
  </div>

  <div id="stage">
    <div id="plateWrap">
      <div id="plateCanvas">
        <div id="baseLayer" class="layer"></div>
        <div id="overlayLayer" class="layer"></div>
      </div>
    </div>
    <div id="caption" class="small"></div>
  </div>

<script>
/*
 compare.html — final fix
 - overlayLayer contains: plate circle + only on-plate items (colored) and is scaled as a group
 - baseLayer contains entire saved scene (template) including side items (gray)
 - normalization enforces gramsPerPortion and fraction; near-0.5 fractions are snapped to 0.5 to keep clipped halves
 - overlay initial scale = 0.92 so growth is visible
*/

const PLATE_CANVAS_PX = 520;
const SESSION_KEY = 'plate_positions_fallback';

// Minimal catalog mapping for gramsPerPortion and image fallback
const CATALOG = {
  potato: { img:'images/potato.svg', gramsPerPortion:150 },
  sausage: { img:'images/sausage.svg', gramsPerPortion:75 },
  carrot: { img:'images/carrot.svg', gramsPerPortion:75 },
  bread: { img:'images/slice-of-bread.svg', gramsPerPortion:40 },
  apple: { img:'images/apple.svg', gramsPerPortion:150 },
  water: { img:'images/glass-of-water.svg', gramsPerPortion:200 },
  milk: { img:'images/milk-carton.svg', gramsPerPortion:250 }
};

let basePayload = null;

// side slots placed to the right so side items don't overlap the plate
function computeSideSlots() {
  const columnX = PLATE_CANVAS_PX + 56;
  const slotStartY = 28;
  const slotSpacing = 56;
  const slotBaseHeight = 48;
  const availableHeight = PLATE_CANVAS_PX - slotStartY - 20;
  const slotStep = slotBaseHeight + slotSpacing;
  const maxSlots = Math.max(4, Math.floor(availableHeight / slotStep));
  const slots = [];
  for (let i=0;i<maxSlots;i++) slots.push({ x: columnX, y: slotStartY + i * slotStep });
  return slots;
}

function loadPayloadFromSession() {
  const raw = sessionStorage.getItem(SESSION_KEY);
  if (!raw) return null;
  try { return JSON.parse(raw); } catch(e){ return null; }
}

// normalize payload entries so fraction & gramsPerPortion exist; snap near-half fractions to exact 0.5
function normalizePayload(payload) {
  const slots = computeSideSlots();
  (payload.positions || []).forEach(p => {
    if (typeof p.id === 'string') p.id = p.id.trim();
    if (CATALOG[p.id]) p.gramsPerPortion = p.gramsPerPortion || CATALOG[p.id].gramsPerPortion;
    else if (p.id === 'bread_variant' || (p.label && p.label.toLowerCase().includes('bread'))) {
      p.gramsPerPortion = p.gramsPerPortion || (CATALOG.bread && CATALOG.bread.gramsPerPortion) || 40;
      if (!p._imgOverride) {
        const lbl = (p.label||'').toLowerCase();
        if (lbl.includes('cheese')) p._imgOverride = 'images/cheese-bread.svg';
        else if (lbl.includes('butter')) p._imgOverride = 'images/bread-with-butter.svg';
        else p._imgOverride = CATALOG.bread.img;
      }
    } else {
      p.gramsPerPortion = p.gramsPerPortion || 100;
    }

    // restore side-slot coordinates if needed
    if (p.placement === 'side') {
      if (typeof p.sideSlot === 'number') {
        const s = slots[Math.min(p.sideSlot, slots.length-1)];
        p.x = s.x; p.y = s.y + Math.round((p.sizePx||40)/2);
      } else if (typeof p.x === 'number' && p.x >= 0 && p.x <= 12 && (!p.y || p.y === 0)) {
        const s = slots[Math.min(p.x, slots.length-1)];
        p.x = s.x; p.y = s.y + Math.round((p.sizePx||40)/2);
        p.sideSlot = p.x;
      }
    }

    // ensure grams present
    if (!('grams' in p) || p.grams == null) {
      if ('fraction' in p && p.fraction && p.gramsPerPortion) p.grams = Math.round(p.fraction * p.gramsPerPortion);
      else if (p.gramsPerPortion) p.grams = p.gramsPerPortion;
      else p.grams = 0;
    }

    // compute fraction (2 decimals)
    if (p.gramsPerPortion && p.grams) p.fraction = Math.round((p.grams / p.gramsPerPortion) * 100) / 100;
    else if (!('fraction' in p)) p.fraction = 1;

    // snap near-half to 0.5 to avoid float-loss of clip-half
    if (Math.abs((p.fraction || 0) - 0.5) < 0.02) p.fraction = 0.5;
  });
}

// render baseLayer: full saved scene (plate + on-plate + side items) in gray
function renderBaseLayer(payload) {
  const baseLayer = document.getElementById('baseLayer');
  baseLayer.innerHTML = '';
  // draw plate background (template) as gray circle to match look
  const plateBg = document.createElement('div');
  plateBg.className = 'plateCircle';
  plateBg.style.background = 'rgba(255,255,255,0.0)'; // keep transparent center; border handled by canvas
  baseLayer.appendChild(plateBg);

  (payload.positions || []).forEach(p => {
    const w = document.createElement('div');
    w.className = 'baseItemWrapper';
    w.style.left = (p.x||0)+'px'; w.style.top = (p.y||0)+'px';
    w.style.width = (p.sizePx||48)+'px'; w.style.height = (p.sizePx||48)+'px';
    w.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    const img = document.createElement('img');
    img.src = (p._imgOverride || (CATALOG[p.id] && CATALOG[p.id].img) || ('images/' + (p.id || 'unknown') + '.svg'));
    img.alt = p.label || p.id || '';
    img.classList.remove('clip-half');
    img.style.transform = '';
    const frac = p.fraction || 1;
    if (Math.abs(frac - 0.5) < 0.001) img.classList.add('clip-half');
    else if (frac < 0.5) img.style.transform = `scale(${Math.max(0.25, Math.min(1, frac))})`;
    // desaturate template images by CSS filter to appear gray (keep same elements)
    img.style.filter = 'grayscale(1)';
    w.appendChild(img);
    baseLayer.appendChild(w);
  });
}

// render overlayLayer: a separate plate circle + only on-plate items in full color (this layer is scaled)
function renderOverlayLayer(payload) {
  const overlay = document.getElementById('overlayLayer');
  overlay.innerHTML = '';
  // overlay plate circle (colored) so scaling affects the visual plate as well
  const plate = document.createElement('div');
  plate.className = 'plateCircle';
  plate.style.background = 'transparent';
  overlay.appendChild(plate);

  // render only on-plate items (do NOT render side items here)
  (payload.positions || []).forEach(p => {
    if (p.placement && p.placement === 'side') return; // skip side items: they stay static in baseLayer

    const w = document.createElement('div');
    w.className = 'overlayItemWrapper';
    w.style.left = (p.x||0) + 'px'; w.style.top = (p.y||0) + 'px';
    w.style.width = (p.sizePx||48) + 'px'; w.style.height = (p.sizePx||48) + 'px';
    w.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    const img = document.createElement('img');
    img.src = (p._imgOverride || (CATALOG[p.id] && CATALOG[p.id].img) || ('images/' + (p.id || 'unknown') + '.svg'));
    img.alt = p.label || p.id || '';
    img.classList.remove('clip-half'); img.style.transform = '';
    const frac = p.fraction || 1;
    if (Math.abs(frac - 0.5) < 0.001) img.classList.add('clip-half');
    else if (frac < 0.5) img.style.transform = `scale(${Math.max(0.25, Math.min(1, frac))})`;
    w.appendChild(img);
    overlay.appendChild(w);
  });
  // overlay starts slightly smaller (ready to grow)
  overlay.style.transform = 'scale(0.92)';
}

// compute totals used for scaling (targetMap expects id -> grams)
function computeTotals(payload, targetMap) {
  const actual = (payload.positions || []).reduce((s,p) => s + (p.grams || 0), 0);
  let target = 0;
  Object.keys(targetMap || {}).forEach(k => { target += (targetMap[k] || 0); });
  return { actual, target };
}

// animate overlayLayer as a single unit (scale = sqrt(target/actual))
function animateWholeOverlay(targetMap, title) {
  if (!basePayload || !basePayload.positions || basePayload.positions.length === 0) { alert('No plate loaded.'); return; }
  document.getElementById('caption').textContent = title || '';

  const { actual, target } = computeTotals(basePayload, targetMap || {});
  const safeActual = Math.max(1, actual);
  const safeTarget = Math.max(0, target);
  let scale = 1.0;
  if (safeTarget <= 0) scale = 0.001;
  else scale = Math.sqrt(safeTarget / safeActual);
  // clamp
  scale = Math.max(0.12, Math.min(3.0, scale));

  // gray template only
  const baseLayer = document.getElementById('baseLayer');
  baseLayer.style.transition = 'filter 400ms ease, opacity 400ms ease';
  baseLayer.style.filter = 'grayscale(1)';
  baseLayer.style.opacity = '0.45';

  // scale overlay group (this contains plate circle + on-plate items)
  const overlay = document.getElementById('overlayLayer');
  overlay.style.transition = `transform 900ms cubic-bezier(.2,.9,.2,1), opacity 400ms ease`;
  overlay.style.transformOrigin = '50% 50%';
  requestAnimationFrame(() => overlay.style.transform = `scale(${scale})`);

  // show diffs in caption
  setTimeout(() => {
    const aggActual = {};
    basePayload.positions.forEach(p => { aggActual[p.id] = (aggActual[p.id]||0) + (p.grams || 0); });
    const diffs = [];
    const ids = new Set([...Object.keys(aggActual), ...Object.keys(targetMap || {})]);
    ids.forEach(id => {
      const a = aggActual[id] || 0;
      const t = (targetMap && (targetMap[id] || 0)) || 0;
      if (Math.abs(a - t) < 1) return;
      const pct = a === 0 ? (t>0 ? 100 : 0) : Math.round(((t - a) / Math.max(1,a)) * 100);
      diffs.push({ id, a, t, pct });
    });
    diffs.sort((x,y) => Math.abs(y.pct) - Math.abs(x.pct));
    const top = diffs.slice(0,6).map(d => {
      const pctLabel = d.a === 0 ? (d.t>0 ? '+100%' : '0%') : ((d.t - d.a)>=0 ? '+' : '') + Math.round(((d.t - d.a)/Math.max(1,d.a))*100) + '%';
      return `${d.id}: ${Math.round(d.a)}g→${Math.round(d.t)}g (${pctLabel})`;
    });
    document.getElementById('caption').textContent = (title ? title + ': ' : '') + (top.length ? top.join('; ') : 'No significant changes');

    // restore template visuals and overlay baseline after a pause (remove if you want overlay to remain scaled)
    setTimeout(() => {
      baseLayer.style.filter = ''; baseLayer.style.opacity = '';
      overlay.style.transform = 'scale(0.92)';
    }, 2200);
  }, 1000);
}

// helper: convert portion counts to grams for recommended example
function portionsToGramsMap(portions) {
  const g = {};
  Object.keys(portions||{}).forEach(id => {
    const per = (CATALOG[id] && CATALOG[id].gramsPerPortion) || (id === 'bread' && CATALOG.bread && CATALOG.bread.gramsPerPortion) || 100;
    g[id] = (portions[id] || 0) * per;
  });
  return g;
}

const recommendedPortions = { carrot:2, apple:1, potato:1, bread:0, sausage:1, milk:1, water:1 };
const recommendedGrams = portionsToGramsMap(recommendedPortions);

// UI wiring
document.getElementById('backBtn').addEventListener('click', () => history.back());
document.getElementById('cmpRecommendedBtn').addEventListener('click', () => animateWholeOverlay(recommendedGrams, 'Recommended (Finland) vs Estimate'));
document.getElementById('cmpRealityBtn').addEventListener('click', () => {
  const raw = prompt('Enter target grams JSON mapping (e.g. { "potato": 200, "apple": 100 }) — leave empty to use recommended');
  let target = null;
  if (!raw) target = recommendedGrams;
  else {
    try { target = JSON.parse(raw); } catch(e){ alert('Invalid JSON'); return; }
  }
  animateWholeOverlay(target, 'Reality vs Estimate');
});

// load payload and render
(function init(){
  const payload = loadPayloadFromSession();
  if (!payload) {
    document.getElementById('caption').textContent = 'No saved plate found in sessionStorage under key: ' + SESSION_KEY;
    return;
  }
  basePayload = payload;
  normalizePayload(basePayload);
  renderBaseLayer(basePayload);
  renderOverlayLayer(basePayload);
})();
</script>
</body>
</html>
