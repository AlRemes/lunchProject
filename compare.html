<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Compare Plate</title>
<style>
  body{font-family:Arial;margin:14px;background:#f6f6f7}
  .topbar{display:flex;gap:12px;align-items:center}
  .btn{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#fff;cursor:pointer}
  #stage{position:relative;width:760px;height:520px;margin:18px auto;border-radius:8px;background:#fff;padding:16px;box-shadow:0 6px 22px rgba(0,0,0,0.08)}
  #plateWrapper{position:relative;width:420px;height:420px;margin:0 auto}
  #plateCanvas{position:relative;width:420px;height:420px;border-radius:50%;background:#fff6e6;border:8px solid #eee;overflow:visible}
  .baseItem{position:absolute;transform:translate(-50%,-50%);opacity:1;filter:none;transition:filter 300ms ease, opacity 300ms ease}
  .overlayItem{position:absolute;transform:translate(-50%,-50%) scale(1);transition:transform 700ms cubic-bezier(.2,.9,.2,1), opacity 500ms ease;opacity:1}
  #caption{margin-top:12px;text-align:center;font-size:14px}
  #controls{width:760px;margin:10px auto;text-align:center}
  select{padding:6px}
</style>
</head>
<body>
  <div class="topbar" style="justify-content:center">
    <button id="backBtn" class="btn">Back</button>
    <button id="cmpRecommendedBtn" class="btn">Compare to Recommended</button>
    <button id="cmpRealityBtn" class="btn">Compare to Reality (pick)</button>
    <select id="pastSelect" class="btn"></select>
    <button id="playAll" class="btn">Play sequence</button>
  </div>

  <div id="stage">
    <div id="plateWrapper">
      <div id="plateCanvas"></div>
    </div>
    <div id="caption"></div>
  </div>

<script>
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbxEpMGjGgkn8a7_RG0-fSyPj-IZny88ZChcqtQ_ks1ALOv0bxrKYTmLy8pSjx0A5euX5A/exec'; // use your URL
const PLATE_DIAMETER = 420; // canvas size here

function qs(name) { const u = new URL(location.href); return u.searchParams.get(name); }

let basePayload = null; // will hold session payload including positions
let overlayElements = []; // DOM elements for overlay items

async function fetchSession(sessionId) {
  const res = await fetch(WEB_APP_URL + '?mode=session&sessionId=' + encodeURIComponent(sessionId));
  if (!res.ok) throw new Error('session fetch failed');
  const json = await res.json();
  return json && json.payload ? json.payload : null;
}
async function fetchRecommended() {
  const res = await fetch(WEB_APP_URL + '?mode=summary');
  if (!res.ok) throw new Error('summary fetch failed');
  return await res.json();
}
async function fetchPastList() {
  const res = await fetch(WEB_APP_URL + '?mode=sessions');
  if (!res.ok) throw new Error('sessions fetch failed');
  return await res.json();
}

/* ------------------ OWID reality fetch + mapping ------------------
   Usage:
     // compare country FIN
     fetchAndCompareReality('FIN').catch(err=>console.error(err));
     // or populate a country selector and call fetchAndCompareReality(code)
------------------------------------------------------------------ */

const OWID_COUNTRY_MAP = { FIN: 'Finland', GBR: 'United Kingdom', TZA: 'Tanzania', 'Eastern Asia (FAO)': 'Eastern Asia (FAO)' };
// adjust/add other mappings as needed

// kcal per portion in your app (tweak if your SIZE_MAP changed)
const KCAL_PER_ITEM = { bread: 80, potato: 160, sausage: 250, milk: 150, cheese: 110, apple: 95, carrot: 25, water: 0 };

// A simple default allocation of lunch kcal into items (fractions of the lunch kcal).
// Tweak these fractions to better reflect typical diets for the country; they must sum to ~1.0 (or less; remaining goes to 'other').
const DEFAULT_LUNCH_ALLOCATION = {
  bread: 0.28,    // cereals / grains
  potato: 0.12,   // roots & tubers
  sausage: 0.25,  // meat / protein
  milk: 0.15,     // dairy
  fruitsveg: 0.18 // fruits + vegetables (we'll split into apple/carrot below)
};

function parseCSV(text) {
  // Minimal CSV parser: returns array of rows (array of cells)
  return text.trim().split('\n').map(r => {
    // rudimentary handling for quoted cells
    const cells = [];
    let cur = '', inQ = false;
    for (let i=0;i<r.length;i++){
      const ch = r[i];
      if (ch === '"' ) { inQ = !inQ; continue; }
      if (ch === ',' && !inQ) { cells.push(cur); cur=''; continue; }
      cur += ch;
    }
    cells.push(cur);
    return cells;
  });
}

async function fetchOWIDTotalKcalForCountry(entityName) {
  // fetch CSV for the chart; include entityName via country param (OWID uses entity names)
  const url = 'https://ourworldindata.org/grapher/daily-per-capita-caloric-supply.csv?country=' + encodeURIComponent(entityName);
  const res = await fetch(url);
  if (!res.ok) throw new Error('OWID fetch failed: ' + res.status);
  const txt = await res.text();
  const rows = parseCSV(txt);
  const header = rows.shift();
  // header likely contains: "Year","Entity","Code","Daily supply of calories per person (kcal)"
  const idxEntity = header.findIndex(h => /entity|country/i.test(h));
  const idxYear = header.findIndex(h => /year/i.test(h));
  const idxValue = header.findIndex(h => /calor/i.test(h));
  if (idxEntity < 0 || idxYear < 0 || idxValue < 0) {
    // fallback: try typical positions
    // throw an error to signal unexpected CSV layout
    throw new Error('Unexpected OWID CSV format; header: ' + header.join('|'));
  }
  // collect year->value for the requested entity
  const vals = {};
  rows.forEach(cells => {
    const ent = cells[idxEntity];
    if (ent !== entityName) return;
    const year = cells[idxYear];
    const v = parseFloat(cells[idxValue]) || 0;
    vals[year] = v;
  });
  const years = Object.keys(vals).map(y=>Number(y)).sort((a,b)=>b-a);
  if (!years.length) return null;
  const latestYear = years[0];
  return { year: latestYear, kcalPerDay: vals[String(latestYear)] };
}

function mapLunchKcalToCounts(lunchKcal, allocation = DEFAULT_LUNCH_ALLOCATION) {
  // allocate lunch kcal to items and turn into integer portion counts
  const counts = {};
  const fruitsvegKcal = (allocation.fruitsveg || 0) * lunchKcal;
  const fvSplit = 0.5; // split fruitsveg kcal half to fruits (apple), half to veg (carrot)
  const byItemKcal = {
    bread: (allocation.bread || 0) * lunchKcal,
    potato: (allocation.potato || 0) * lunchKcal,
    sausage: (allocation.sausage || 0) * lunchKcal,
    milk: (allocation.milk || 0) * lunchKcal,
    apple: fruitsvegKcal * fvSplit,
    carrot: fruitsvegKcal * (1 - fvSplit),
    water: 0
  };
  Object.entries(byItemKcal).forEach(([item, kcal]) => {
    const per = KCAL_PER_ITEM[item] || 100;
    const raw = (kcal / per);
    // make small non-zero portions show as 1 rather than 0 when kcal>0
    counts[item] = (kcal > 0 && raw > 0 && raw < 0.5) ? 1 : Math.round(raw);
    if (!isFinite(counts[item]) || counts[item] < 0) counts[item] = 0;
  });
  return counts;
}

async function fetchAndCompareReality(countryCode = 'FIN') {
  try {
    const entity = OWID_COUNTRY_MAP[countryCode] || countryCode;
    const result = await fetchOWIDTotalKcalForCountry(entity);
    if (!result) { alert('No OWID data for ' + entity); return; }
    const daily = result.kcalPerDay;
    // estimate lunch as one third of daily supply
    const lunch = daily / 3;
    const counts = mapLunchKcalToCounts(lunch);
    const title = `Reality (approx) ${entity} ${result.year}: ${Math.round(daily)} kcal/day, lunch ≈ ${Math.round(lunch)} kcal`;
    animateComparison(counts, title);
  } catch (err) {
    console.error('fetchAndCompareReality error', err);
    alert('Failed to fetch reality data: ' + (err.message || err));
  }
}

// load initial session: from URL sessionId or fallback sessionStorage
async function loadBase() {
  const sid = qs('sessionId');
  if (sid) {
    basePayload = await fetchSession(sid);
  } else {
    const fallback = sessionStorage.getItem('plate_positions_fallback');
    if (fallback) basePayload = JSON.parse(fallback);
  }
  if (!basePayload) {
    alert('No session found. Return to build page and save a session.');
    return;
  }
  renderBasePlate(basePayload);
  populatePastSelect();
}

// render the anchored base plate exactly using positions in basePayload.positions
function renderBasePlate(payload) {
  const canvas = document.getElementById('plateCanvas');
  canvas.innerHTML = '';
  // background base: draw each saved position as a faded baseItem
  const positions = payload.positions || [];
  positions.forEach(p => {
    const img = document.createElement('img');
    img.src = (p.id && ('images/' + p.id + '.svg')) || '';
    img.className = 'baseItem';
    img.style.left = p.x + 'px';
    img.style.top = p.y + 'px';
    img.style.width = (p.sizePx || 48) + 'px';
    img.style.height = (p.sizePx || 48) + 'px';
    img.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    canvas.appendChild(img);
  });
  // remember anchor positions for overlay math
  basePayload._anchorMap = {};
  positions.forEach(p => {
    basePayload._anchorMap[p.id] = basePayload._anchorMap[p.id] || [];
    basePayload._anchorMap[p.id].push(p);
  });
}
document.getElementById('cmpRealityBtn').addEventListener('click', () => {
  const sel = document.getElementById('pastSelect'); // reuse or add a country select
  const code = sel && sel.value ? sel.value : 'FIN';
  fetchAndCompareReality(code);
});

// create overlay items (one DOM element per anchor position) and return array
function createOverlayElements() {
  const canvas = document.getElementById('plateCanvas');
  // remove previous overlay elements
  document.querySelectorAll('.overlayItem').forEach(n=>n.remove());
  overlayElements = [];
  const positions = basePayload.positions || [];
  positions.forEach(p => {
    const img = document.createElement('img');
    img.src = (p.id && ('images/' + p.id + '.svg')) || '';
    img.className = 'overlayItem';
    img.style.left = p.x + 'px';
    img.style.top = p.y + 'px';
    img.style.width = (p.sizePx || 48) + 'px';
    img.style.height = (p.sizePx || 48) + 'px';
    img.style.transform = `translate(-50%,-50%) scale(1) rotate(${p.rotationDeg||0}deg)`;
    img.style.opacity = '0';
    canvas.appendChild(img);
    overlayElements.push({ el: img, id: p.id, anchor: p });
  });
  return overlayElements;
}

// Finland-aligned recommended lunch (approximation based on Ruokavirasto guidance, lunch ~= 1/3 daily)


// animate overlay to represent targetCounts (object id->count). Items are anchored, they DO NOT move.
// scaling: find anchorCount per id (how many anchors exist for that id), then compute target total instances for id,
// compute per-anchor scale = sqrt(targetInstances / anchorCount) or 0 if target is 0.
function animateComparison(targetCounts, title) {
  document.querySelectorAll('.baseItem').forEach(el => {
    el.style.filter = 'none';
    el.style.opacity = '1';
  });
  const caption = document.getElementById('caption');
  caption.textContent = title || '';
  const anchorsById = {};
  basePayload.positions.forEach(p => (anchorsById[p.id] = anchorsById[p.id] || []).push(p));
  const overlay = createOverlayElements();
  // set initial opacity and scale to 0.001 so they pop in at correct anchor
  overlay.forEach(o => { o.el.style.opacity = '1'; o.el.style.transform = `translate(-50%,-50%) scale(0.001) rotate(${o.anchor.rotationDeg||0}deg)`; });

  // compute target instances count per id (rounding rules: use provided count or fallback to Math.round(avg))
  // targetCounts is an object id->count (numbers)
  document.querySelectorAll('.baseItem').forEach(el => {
    el.style.filter = 'grayscale(1)';
    el.style.opacity = '0.45';
  });
  const anchorCountById = {};
  Object.keys(anchorsById).forEach(id=> anchorCountById[id] = anchorsById[id].length);

  // For each overlay element, compute scale
  overlay.forEach(o => {
    const id = o.id;
    const anchorCount = anchorCountById[id] || 1;
    const targetInstances = Math.max(0, targetCounts[id] || 0);
    // ratio area-based -> sqrt
    const ratio = anchorCount === 0 ? (targetInstances > 0 ? targetInstances : 0) : (targetInstances / anchorCount);
    let scale = Math.sqrt(Math.max(0.0001, ratio));
    // clamp for visual sanity
    scale = Math.max(0.25, Math.min(2.6, scale));
    // gray the base template now so comparison overlay stands out
    document.querySelectorAll('.baseItem').forEach(el => {
      el.style.filter = 'grayscale(1)';
      el.style.opacity = '0.45';
    });
    // apply transform after tiny delay to ensure transition
    setTimeout(()=> {
      o.el.style.transform = `translate(-50%,-50%) scale(${scale}) rotate(${o.anchor.rotationDeg||0}deg)`;
      o.el.style.opacity = '1';
    }, 40);
  });

  // show summary text under plate
  setTimeout(()=> {
    // compute diffs
    const diffs = [];
    const allIds = new Set([...Object.keys(anchorCountById), ...Object.keys(targetCounts)]);
    allIds.forEach(id=>{
      const a = anchorCountById[id] || 0;
      const t = targetCounts[id] || 0;
      if (a === t) return;
      const pct = a === 0 ? 100 : Math.round(((t - a) / a) * 100);
      diffs.push({ id, a, t, pct });
    });
    diffs.sort((x,y)=> Math.abs(y.pct) - Math.abs(x.pct));
    const top = diffs.slice(0,5).map(d => `${d.id}: ${d.a}→${d.t} (${d.pct>0?'+':''}${d.pct}%)`);
    caption.textContent = (title ? title + ' — ' : '') + (top.length ? top.join('; ') : 'No changes');
  }, 900);

}
const recommendedCountsFinlandLunch = {
  // vegetables & fruits (split veg 60% veg, 40% fruit of the lunch veg+fruit budget)
  carrot: 2,     // ~2 carrots (vegetable portions)
  apple: 1,      // 1 medium apple (fruit portion)
  // staple: one or two starchy portions (potato or bread)
  potato: 1,     // 1 medium potato OR
  bread: 1,      // 1 slice (either/or; counts can combine)
  // protein and dairy
  sausage: 1,    // 1 small protein portion (prefer plant/lean proteins in reality)
  milk: 1,       // 1 small milk/dairy portion
  // extras / hydration
  water: 1
};

// helpers to convert recommended/session payloads into id->count maps
function itemsArrayToCounts(items) {
  const map = {};
  (items||[]).forEach(it => { map[it.id] = (map[it.id]||0) + (it.count||1); });
  return map;
}

// UI wiring
document.getElementById('backBtn').addEventListener('click', ()=> { window.location.href = 'index.html'; });

document.getElementById('cmpRecommendedBtn').addEventListener('click', async () => {
  // pick region: use FIN mapping for Finland; in a full app you'd switch by selected country
  const recommended = recommendedCountsFinlandLunch;
  animateComparison(recommended, 'Recommended (Finland) vs Estimate');
});

document.getElementById('pastSelect').addEventListener('change', ()=>{/* nothing: wait for manual compare */});

document.getElementById('cmpRealityBtn').addEventListener('click', async ()=> {
  const sel = document.getElementById('pastSelect');
  if (!sel || !sel.value) { alert('Pick a session from the selector'); return; }
  try {
    const payload = await fetchSession(sel.value);
    if (!payload) { alert('No payload returned'); return; }
    const counts = itemsArrayToCounts(payload.items || []);
    animateComparison(counts, 'Reality vs Estimate');
  } catch (err) {
    console.error(err); alert('Failed to fetch session');
  }
});

// Play sequence button: recommended -> reality (selected) -> previous selected (if any)
document.getElementById('playAll').addEventListener('click', async ()=> {
  // recommended
  document.getElementById('cmpRecommendedBtn').click();
  await new Promise(r=>setTimeout(r, 2400));
  // reality (selected)
  const sel = document.getElementById('pastSelect');
  if (sel && sel.value) {
    document.getElementById('cmpRealityBtn').click();
    await new Promise(r=>setTimeout(r, 2400));
  }
});

// populate past select
async function populatePastSelect() {
  try {
    const res = await fetch(WEB_APP_URL + '?mode=sessions');
    if (!res.ok) throw new Error('sessions fetch failed');
    const json = await res.json();
    const sel = document.getElementById('pastSelect');
    sel.innerHTML = '';
    (json.sessions||[]).forEach(s=>{
      const opt = document.createElement('option');
      opt.value = s.sessionId;
      opt.textContent = `${s.label || s.sessionId} — ${s.timestamp || ''}`;
      sel.appendChild(opt);
    });
  } catch (err) {
    console.warn('populatePastSelect', err);
  }
}

loadBase();
</script>
</body>
</html>
