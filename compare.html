<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Compare Plate — scale by total calories (with global reality)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root {
    --plate-wrapper-size: 520px;
    --plate-diameter: 480px;
  }
  body{font-family:Arial,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;margin:14px;background:#f6f6f7;color:#222}
  .page{max-width:1200px;margin:0 auto}
  .topbar{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
  .btn{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#fff;cursor:pointer}
  .panels{display:flex;flex-direction:column;gap:36px;padding-bottom:120px}
  .panel{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 22px rgba(0,0,0,0.06)}
  .panelHeader{display:flex;gap:10px;align-items:center;margin-bottom:8px}
  .panelTitle{font-weight:600}
  .canvasRow{display:flex;gap:18px;align-items:flex-start}
  .plateCanvas{
    position:relative;
    width:var(--plate-wrapper-size);
    height:var(--plate-wrapper-size);
    background:#fff6e6;
    border:8px solid #eee;
    overflow:visible;
    padding:0;
    box-sizing:border-box;
    border-radius:50%;
  }
  .layer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
  .sideColumn{position:absolute;top:14px;right:18px;display:flex;flex-direction:column;gap:10px;pointer-events:none}
  .sideColumn.left{right:auto;left:18px}
  .sideItem{width:86px;height:86px;display:flex;align-items:center;justify-content:center}
  .plate-area {
    position:absolute;
    left:50%; top:50%;
    width:var(--plate-diameter); height:var(--plate-diameter);
    transform:translate(-50%,-50%) scale(1);
    transform-origin:50% 50%;
    border-radius:50%;
    pointer-events:none;
    background:transparent;
  }
  .ghostGroup, .scaledGroup{
    position:absolute; left:50%; top:50%;
    width:var(--plate-diameter); height:var(--plate-diameter);
    transform:translate(-50%,-50%) scale(1);
    transform-origin:50% 50%;
    pointer-events:none; overflow:visible; border-radius:50%;
  }
  .overlayFill{
    position:absolute; left:50%; top:50%;
    transform:translate(-50%,-50%); border-radius:50%;
    pointer-events:none; box-sizing:border-box;
  }
  .scaledSvg{position:absolute;left:0;top:0;width:100%;height:100%}
  .itemWrapper{position:absolute; transform:translate(-50%,-50%); pointer-events:none}
  .itemWrapper img{display:block;width:100%;height:100%;object-fit:contain}
  .ghost-img{filter:grayscale(100%) contrast(80%); opacity:0.45}
  .ghost-inner{filter:grayscale(100%) contrast(80%); opacity:0.18}
  .scaled-img{filter:none; opacity:1}
  .clip-half { -webkit-clip-path: polygon(0 0, 100% 100%, 0 100%); clip-path: polygon(0 0, 100% 100%, 0 100%); }
  .caption{font-size:13px;color:#333;margin-top:8px;max-width:420px}
  .annulus{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;pointer-events:none;opacity:0.95;box-sizing:border-box}
  .hidden-onplate { opacity:0; transform:scale(0.98); transition:opacity 220ms ease, transform 220ms ease; pointer-events:none; }
  .controlsRow{display:flex;gap:8px;align-items:center}
  select.countrySelect{padding:6px;border-radius:6px;border:1px solid #ccc;background:#fff}
  .note{font-size:12px;color:#666;margin-top:6px}
  @media (max-width:1000px){
    :root{ --plate-wrapper-size:420px; --plate-diameter:380px; }
    .sideColumn{right:12px}
  }
</style>
</head>
<body>
  <div class="page">
    <div class="topbar">
      <div style="display:flex;gap:12px;align-items:center">
        <button id="backBtn" class="btn">Back</button>
        <div class="small" style="color:#444">Compare your plate to Finland recommendation and to average lunches around the world (Our World in Data)</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="resetAllBtn" class="btn">Reset Comparisons</button>
      </div>
    </div>

    <div class="panels">
      <div class="panel">
        <div class="panelHeader">
          <div class="panelTitle">Compare to Recommended (Finland)</div>
          <div class="spacer"></div>
          <div class="controlsRow">
            <button id="cmpRecommendedBtn" class="btn">Run Compare</button>
            <button id="clearRecommendedBtn" class="btn">Clear</button>
          </div>
        </div>

        <div class="canvasRow" style="position:relative">
          <div class="plateCanvas" id="canvasRecommended">
            <div class="layer" id="baseRecommended"></div>
            <div class="layer" id="annulusRecommended"></div>
            <div class="layer" id="overlayRecommended"></div>
            <div class="sideColumn" id="sideRec"></div>
          </div>

          <div>
            <div class="caption" id="captionRecommended">Press Run Compare to scale the plate to Finnish recommendation.</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <div class="panelTitle">Compare to Reality (global lunch estimates)</div>
          <div class="spacer"></div>
          <div class="controlsRow">
            <select id="countrySelect" class="countrySelect"></select>
            <button id="cmpRealityBtn" class="btn">Compare to Country</button>
            <button id="clearRealityBtn" class="btn">Clear</button>
          </div>
        </div>

        <div class="canvasRow" style="position:relative">
          <div class="plateCanvas" id="canvasReality">
            <div class="layer" id="baseReality"></div>
            <div class="layer" id="annulusReality"></div>
            <div class="layer" id="overlayReality"></div>
            <div class="sideColumn" id="sideReal"></div>
          </div>

          <div>
            <div class="caption" id="captionReality">Select a country (data from Our World in Data) and click Compare. The daily calories per person (latest year) are divided by 3 to approximate a lunch-sized target and used to build a comparison plate automatically.</div>
            <div class="note">Countries included: Finland, Sweden, Norway, Denmark, United States, Canada, Brazil, Argentina, Chile, China, India, Japan, Indonesia, Australia, New Zealand, Nigeria, Ethiopia, Kenya, South Africa, Egypt, Morocco</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  Updated compare.html — now includes:
   - fetch of Our World in Data daily-per-capita-caloric-supply CSV
   - builds a country list (scandinavia, americas, asia, oceania, south america, several african countries)
   - computes lunch estimate = daily kcal / 3 (latest available year)
   - converts lunch kcal -> grams using avgKcalPerGram
   - builds a simple target grams map and runs the existing runCompare() against the second panel
   - preserves previous visual compare behaviour
*/

const SESSION_KEY = 'plate_positions_fallback';
const OWID_CSV = 'https://ourworldindata.org/grapher/daily-per-capita-caloric-supply.csv';

const CAL_PER_G = {
  potato: 0.77, sausage: 2.5, carrot: 0.41,
  bread_variant: 2.5, bread: 2.5, apple: 0.52,
  orange: 0.47, milk: 0.64, water: 0.0
};

const CATALOG_IMG = {
  potato: 'images/potato.svg',
  sausage: 'images/sausage.svg',
  carrot: 'images/carrot.svg',
  bread_variant: 'images/cheese-bread.svg',
  bread_with_butter: 'images/bread-with-butter.svg',
  slice_of_bread: 'images/slice-of-bread.svg',
  bread: 'images/slice-of-bread.svg',
  apple: 'images/apple.svg',
  milk: 'images/milk-carton.svg',
  water: 'images/glass-of-water.svg'
};

const DEFAULT_GRAMS = { potato:150, sausage:75, carrot:75, bread:40, bread_variant:40, apple:150, milk:250, water:200 };

/* countries we will expose */
const COUNTRY_LIST = [
  "Finland","Sweden","Norway","Denmark",
  "United States","Canada",
  "Brazil","Argentina","Chile",
  "China","India","Japan","Indonesia",
  "Australia","New Zealand",
  "Nigeria","Ethiopia","Kenya","South Africa","Egypt",
  "Morocco"
];

let owidDataByCountry = {}; // { country: { year: kcal, ... }, ... }
let latestKcalByCountry = {}; // { country: latestKcal }

// DOM refs
const countrySelect = document.getElementById('countrySelect');
const cmpRealityBtn = document.getElementById('cmpRealityBtn');
const clearRealityBtn = document.getElementById('clearRealityBtn');

const baseRec = document.getElementById('baseRecommended');
const annRec  = document.getElementById('annulusRecommended');
const overRec = document.getElementById('overlayRecommended');
const sideRec = document.getElementById('sideRec');
const capRec  = document.getElementById('captionRecommended');

const baseReal = document.getElementById('baseReality');
const annReal  = document.getElementById('annulusReality');
const overReal = document.getElementById('overlayReality');
const sideReal = document.getElementById('sideReal');
const capReal  = document.getElementById('captionReality');

let payload = null;

/* Utilities to parse CSV (simple, small parser) */
function parseCsv(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (lines.length === 0) return [];
  const header = lines[0].split(',');
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const line = lines[i];
    // naive CSV split (OWID CSV uses simple values)
    const cols = line.split(',');
    if (cols.length !== header.length) continue;
    const obj = {};
    for (let j=0;j<header.length;j++){
      obj[header[j]] = cols[j];
    }
    rows.push(obj);
  }
  return { header, rows };
}

/* Load OWID CSV and populate latestKcalByCountry for our COUNTRY_LIST */
async function fetchOwid(){
  try {
    const res = await fetch(OWID_CSV);
    if (!res.ok) throw new Error('CSV fetch failed ' + res.status);
    const txt = await res.text();
    const parsed = parseCsv(txt);
    // CSV columns: country, year, total (or value) — inspect header names
    const hdr = parsed.header;
    const rows = parsed.rows;
    // find the value column (commonly "Daily supply of calories per person")
    // Inspect headers; typical grapher CSV has column names like "Country","Year","Daily supply of calories per person"
    // We'll locate the numeric column that's not "country" or "year"
    const valCol = hdr.find(h => !['country','Year','year','Country','Entity'].includes(h));
    rows.forEach(r => {
      const country = r['country'] || r['Country'] || r['Entity'] || r['entity'] || '';
      const year = Number(r['year'] || r['Year'] || '');
      const v = Number(r[valCol]);
      if (!country || isNaN(year) || isNaN(v)) return;
      if (!owidDataByCountry[country]) owidDataByCountry[country] = {};
      owidDataByCountry[country][year] = v;
    });

    // build latestKcalByCountry for our COUNTRY_LIST
    COUNTRY_LIST.forEach(c => {
      const data = owidDataByCountry[c];
      if (!data) { latestKcalByCountry[c] = null; return; }
      const years = Object.keys(data).map(Number).filter(y => !isNaN(y));
      if (years.length === 0){ latestKcalByCountry[c] = null; return; }
      const latestYear = Math.max(...years);
      latestKcalByCountry[c] = { year: latestYear, kcal: data[latestYear] };
    });
  } catch (e) {
    console.warn('Failed to fetch OWID CSV', e);
    // fallback: keep latestKcalByCountry empty
    COUNTRY_LIST.forEach(c => latestKcalByCountry[c] = null);
  }
}

/* Fill country select with readable labels and (kcal/year) info when available */
function populateCountrySelect(){
  countrySelect.innerHTML = '';
  COUNTRY_LIST.forEach(c => {
    const info = latestKcalByCountry[c];
    const label = info && info.kcal ? `${c} — ${Math.round(info.kcal)} kcal/day (${info.year})` : `${c} — (no data)`;
    const opt = document.createElement('option');
    opt.value = c;
    opt.textContent = label;
    countrySelect.appendChild(opt);
  });
}

/* Helpers re-using existing compare code (simplified duplicates included here) */

function computeSideSlots(canvasEl){
  const rect = canvasEl.getBoundingClientRect();
  const plateDiameter = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--plate-diameter')) || 480;
  const plateRight = (rect.width/2) + (plateDiameter/2);
  const gap = Math.max(8, Math.round(Math.min(rect.width, rect.height) * 0.02));
  const columnX = Math.min(rect.width - 30, Math.round(plateRight + gap));
  const startY = 40;
  const spacing = 18 + 86;
  const slots = [];
  const max = Math.max(4, Math.floor((rect.height - startY - 20) / spacing));
  for (let i=0;i<max;i++) slots.push({ x: columnX, y: startY + i * spacing });
  return slots;
}

function escapeAttr(s){ return String(s||'').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function resolveImage(p){
  if (p._imgOverride) return p._imgOverride;
  if (p.id === 'bread_variant') return CATALOG_IMG.bread_variant;
  if (p.id === 'bread_with_butter') return CATALOG_IMG.bread_with_butter;
  if (p.id === 'slice_of_bread') return CATALOG_IMG.slice_of_bread;
  if (p.id && CATALOG_IMG[p.id]) return CATALOG_IMG[p.id];
  return 'images/' + (p.id || 'unknown') + '.svg';
}

/* Render base (original items) */
function renderBase(targetBase, sideContainer){
  targetBase.innerHTML = '';
  sideContainer.innerHTML = '';

  const plateArea = document.createElement('div');
  plateArea.className = 'plate-area';
  plateArea.style.background = 'transparent';
  targetBase.appendChild(plateArea);

  const slots = computeSideSlots(targetBase.parentElement);

  (payload.positions || []).forEach(p => {
    if (p.placement === 'side') {
      const idx = (typeof p.sideSlot === 'number') ? p.sideSlot : 0;
      const chosen = slots[Math.min(idx, slots.length-1)] || {x:targetBase.parentElement.clientWidth-100,y:40};
      const si = document.createElement('div');
      si.className = 'sideItem';
      si.style.position = 'absolute';
      si.style.left = (chosen.x - 40) + 'px';
      si.style.top = (chosen.y - 20) + 'px';
      const src = p._imgOverride || resolveImage(p);
      si.innerHTML = `<img src="${escapeAttr(src)}" alt="${escapeAttr(p.label||p.id||'')}" style="width:100%;height:100%;object-fit:contain">`;
      sideContainer.appendChild(si);
      return;
    }

    const w = document.createElement('div');
    w.className = 'itemWrapper';
    w.dataset.onplate = '1';
    w.style.position = 'absolute';
    w.style.left = (p.x||0) + 'px';
    w.style.top = (p.y||0) + 'px';
    w.style.width = (p.sizePx||48) + 'px';
    w.style.height = (p.sizePx||48) + 'px';
    w.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    const img = document.createElement('img');
    img.src = p._imgOverride || resolveImage(p);
    img.alt = p.label || p.id || '';
    img.classList.remove('clip-half'); img.style.transform = '';
    const frac = (typeof p.fraction === 'number') ? p.fraction : 1;
    if (Math.abs(frac - 0.5) < 0.001) img.classList.add('clip-half');
    else if (frac < 0.5) img.style.transform = `scale(${Math.max(0.25, Math.min(1, frac))})`;
    w.appendChild(img);
    targetBase.appendChild(w);
  });
}

/* Build overlay (ghost + scaled) */
function buildOverlay(targetOverlay){
  targetOverlay.innerHTML = '';
  const container = document.createElement('div');
  container.className = 'scaledContainer';
  container.style.position='absolute'; container.style.left='0'; container.style.top='0';
  container.style.width='100%'; container.style.height='100%';

  const ghost = document.createElement('div'); ghost.className = 'ghostGroup';
  const ghostInnerLayer = document.createElement('div'); ghostInnerLayer.className = 'ghostGroup ghost-inner-group';
  const scaled = document.createElement('div'); scaled.className = 'scaledGroup';

  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox','0 0 100 100');
  svg.setAttribute('preserveAspectRatio','xMidYMid meet');
  svg.className = 'scaledSvg';
  svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0'; svg.style.width='100%'; svg.style.height='100%';
  const circle = document.createElementNS(svgNS,'circle');
  circle.setAttribute('cx','50'); circle.setAttribute('cy','50'); circle.setAttribute('r','49.5');
  circle.setAttribute('fill','transparent'); circle.setAttribute('stroke','transparent');
  svg.appendChild(circle);
  scaled.appendChild(svg);

  (payload.positions || []).forEach(p => {
    if (p.placement !== 'onplate') return;

    // ghost (grey original)
    const gw = document.createElement('div');
    gw.className = 'itemWrapper';
    gw.style.position = 'absolute';
    gw.style.left = (p.x||0) + 'px';
    gw.style.top  = (p.y||0) + 'px';
    gw.style.width = (p.sizePx||48) + 'px';
    gw.style.height = (p.sizePx||48) + 'px';
    gw.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    const gimg = document.createElement('img');
    gimg.src = p._imgOverride || resolveImage(p);
    gimg.alt = p.label || p.id || '';
    gimg.className = 'ghost-img';
    const gfrac = (typeof p.fraction === 'number') ? p.fraction : 1;
    if (Math.abs(gfrac - 0.5) < 0.001) gimg.classList.add('clip-half');
    else if (gfrac < 0.5) gimg.style.transform = `scale(${Math.max(0.25, Math.min(1, gfrac))})`;
    gw.appendChild(gimg);
    ghost.appendChild(gw);

    // ghost-inner (faint inner grey)
    const giw = document.createElement('div');
    giw.className = 'itemWrapper';
    giw.style.position = 'absolute';
    giw.style.left = (p.x||0) + 'px';
    giw.style.top  = (p.y||0) + 'px';
    giw.style.width = (p.sizePx||48) + 'px';
    giw.style.height = (p.sizePx||48) + 'px';
    giw.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg) scale(0.86)`;
    const giimg = document.createElement('img');
    giimg.src = p._imgOverride || resolveImage(p);
    giimg.alt = p.label || p.id || '';
    giimg.className = 'ghost-inner';
    if (Math.abs(gfrac - 0.5) < 0.001) giimg.classList.add('clip-half');
    giw.appendChild(giimg);
    ghostInnerLayer.appendChild(giw);

    // scaled (recommendation)
    const sw = document.createElement('div');
    sw.className = 'itemWrapper';
    sw.style.position = 'absolute';
    sw.style.left = (p.x||0) + 'px';
    sw.style.top  = (p.y||0) + 'px';
    sw.style.width = (p.sizePx||48) + 'px';
    sw.style.height = (p.sizePx||48) + 'px';
    sw.dataset.rotate = (p.rotationDeg||0);
    sw.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg) scale(1)`;
    const simg = document.createElement('img');
    simg.src = p._imgOverride || resolveImage(p);
    simg.alt = p.label || p.id || '';
    simg.className = 'scaled-img';
    const sfrac = (typeof p.fraction === 'number') ? p.fraction : 1;
    if (Math.abs(sfrac - 0.5) < 0.001) simg.classList.add('clip-half');
    else if (sfrac < 0.5) simg.style.transform = `scale(${Math.max(0.25, Math.min(1, sfrac))})`;
    sw.appendChild(simg);
    scaled.appendChild(sw);
  });

  container.appendChild(ghost);
  container.appendChild(ghostInnerLayer);
  container.appendChild(scaled);
  targetOverlay.appendChild(container);
  targetOverlay._ghost = ghost;
  targetOverlay._ghostInner = ghostInnerLayer;
  targetOverlay._scaled = scaled;
}

/* Draw annulus/fill */
function drawAnnulus(node, scale){
  node.innerHTML = '';
  if (!scale || isNaN(scale)) return;
  const base = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--plate-diameter')) || 480;
  const scaled = Math.max(2, base * scale);

  if (scale >= 1) {
    const ann = document.createElement('div');
    ann.className = 'annulus';
    ann.style.position = 'absolute';
    ann.style.left = '50%';
    ann.style.top = '50%';
    ann.style.transform = 'translate(-50%,-50%)';
    ann.style.boxSizing = 'border-box';
    const outer = scaled;
    const thickness = Math.max(4, (scaled - base) / 2);
    ann.style.width = outer + 'px';
    ann.style.height = outer + 'px';
    ann.style.border = `${thickness}px solid rgba(88, 196, 104, 0.95)`;
    node.appendChild(ann);
  } else {
    const fill = document.createElement('div');
    fill.className = 'overlayFill';
    fill.style.width = scaled + 'px';
    fill.style.height = scaled + 'px';
    fill.style.background = 'rgba(220, 70, 70, 0.22)';
    fill.style.border = `1px solid rgba(220,70,70,0.28)`;
    fill.style.left = '50%';
    fill.style.top = '50%';
    fill.style.transform = 'translate(-50%,-50%)';
    node.appendChild(fill);

    const rim = document.createElement('div');
    rim.className = 'annulus';
    rim.style.position = 'absolute';
    rim.style.left = '50%';
    rim.style.top = '50%';
    rim.style.transform = 'translate(-50%,-50%)';
    rim.style.boxSizing = 'border-box';
    const outer = scaled;
    const thickness = Math.max(2, Math.min(8, Math.round(outer * 0.02)));
    rim.style.width = outer + 'px';
    rim.style.height = outer + 'px';
    rim.style.border = `${thickness}px solid rgba(220,70,70,0.22)`;
    node.appendChild(rim);
  }
}

/* helpers for calories -> grams conversion and target map construction
   We'll use avgKcalPerGram = 1.5 (approximate mixed diet).
   Build a target map distributing grams across common items to reach the kcal target.
*/
const avgKcalPerGram = 1.5;

function kcalToGrams(kcal){
  return Math.max(0, Math.round(kcal / avgKcalPerGram));
}

/* Build a simple grams map by splitting target grams across a few items
   If payload contains certain item ids, try to preserve those ids; otherwise use a fixed list.
*/
function buildTargetGramsMap(totalGrams){
  const idsPreferred = ['potato','carrot','bread_variant','sausage','apple','milk'];
  const map = {};
  let remaining = totalGrams;
  const n = idsPreferred.length;
  // distribute roughly evenly but give bread and potato more weight
  const weights = [1.3,1,1.1,0.9,0.9,1.0];
  const totalW = weights.reduce((s,w)=>s+w,0);
  idsPreferred.forEach((id,i)=>{
    const g = Math.round((weights[i]/totalW) * totalGrams);
    map[id] = g;
    remaining -= g;
  });
  // adjust leftover
  let i = 0;
  while (remaining > 0) {
    const key = idsPreferred[i % n];
    map[key] = (map[key] || 0) + 1;
    remaining--;
    i++;
  }
  return map;
}

/* Reuse existing runCompare / clearCompare implementations adapted for our DOM nodes.
   For brevity we keep a compact version here that calls previously defined helpers.
*/

function totalCaloriesFromMap(map){
  let sum = 0;
  Object.keys(map || {}).forEach(id => {
    const grams = map[id] || 0;
    const calPerG = CAL_PER_G[id] !== undefined ? CAL_PER_G[id] : 0.8;
    sum += grams * calPerG;
  });
  return sum;
}
function totalCaloriesPayloadFromPositions(positions){
  return (positions || []).reduce((s,p) => {
    if (typeof p.kcalPerPortion === 'number' && typeof p.gramsPerPortion === 'number' && p.gramsPerPortion > 0) {
      const calPerG = (p.kcalPerPortion / p.gramsPerPortion);
      return s + (p.grams || 0) * calPerG;
    }
    const calPerG = CAL_PER_G[p.id] !== undefined ? CAL_PER_G[p.id] : 0.8;
    return s + (p.grams || 0) * calPerG;
  }, 0);
}
function totalCaloriesPayload(){
  if (payload && typeof payload.totalCalories === 'number') return Math.max(0, Math.round(payload.totalCalories));
  return Math.max(0, Math.round(totalCaloriesPayloadFromPositions(payload.positions || [])));
}

function computeScaleFromCalories(targetMap){
  const actual = Math.max(1, totalCaloriesPayload());
  const target = Math.max(0, totalCaloriesFromMap(targetMap || {}));
  if (target <= 0) return 0.001;
  return Math.max(0.12, Math.min(3.0, Math.sqrt(target / actual)));
}

/* place side column left/right */
function placeSideColumn(sideContainer, toRight){
  if (!sideContainer) return;
  sideContainer.classList.remove('left');
  if (!toRight) sideContainer.classList.add('left');
}

/* runCompare adapted (uses previously defined buildOverlay, drawAnnulus, etc.)
   targetMap is grams per id (e.g. { potato: 150, ... })
*/
function runCompare(targetOverlay, targetBase, annNode, sideContainer, captionEl, targetMap, title){
  if (!payload) { alert('No saved plate'); return; }

  targetOverlay.innerHTML = '';
  annNode.innerHTML = '';
  sideContainer.innerHTML = '';

  // render static side items (colored)
  renderSideOnly(sideContainer, targetBase);

  buildOverlay(targetOverlay);

  const scale = computeScaleFromCalories(targetMap);

  // hide base on-plate items (we show ghost + scaled overlay)
  Array.from(targetBase.querySelectorAll('.itemWrapper')).forEach(el => {
    if (el.dataset.onplate === '1') el.classList.add('hidden-onplate');
  });

  // scale plate-area
  const plateArea = targetBase.querySelector('.plate-area');
  if (plateArea) {
    plateArea.style.transition = 'transform 700ms cubic-bezier(.2,.9,.2,1)';
    requestAnimationFrame(()=> plateArea.style.transform = `translate(-50%,-50%) scale(${scale})`);
  }

  // draw annulus/fill
  drawAnnulus(annNode, scale);

  // style ghost vs scaled
  const ghostImgs = targetOverlay._ghost ? Array.from(targetOverlay._ghost.querySelectorAll('img')) : [];
  const ghostInnerImgs = targetOverlay._ghostInner ? Array.from(targetOverlay._ghostInner.querySelectorAll('img')) : [];
  const scaledImgs = targetOverlay._scaled ? Array.from(targetOverlay._scaled.querySelectorAll('img')) : [];

  ghostImgs.forEach(i => { i.className = 'ghost-img'; });
  ghostInnerImgs.forEach(i => { i.className = 'ghost-inner'; });
  scaledImgs.forEach(i => { i.className = 'scaled-img'; });

  // scale each recommendation item around its center
  const scaledGroup = targetOverlay._scaled;
  if (scaledGroup) {
    Array.from(scaledGroup.querySelectorAll('.itemWrapper')).forEach(sw => {
      const rotate = Number(sw.dataset.rotate || 0);
      sw.style.transition = 'transform 700ms cubic-bezier(.2,.9,.2,1)';
      requestAnimationFrame(()=> sw.style.transform = `translate(-50%,-50%) rotate(${rotate}deg) scale(${scale})`);
    });
  }

  // side column placement
  const actualCal = Math.round(totalCaloriesPayload());
  const targetCal = Math.round(totalCaloriesFromMap(targetMap || {}));
  placeSideColumn(sideContainer, targetCal >= actualCal);

  // friendly caption text
  setTimeout(()=> {
    let diffPct = 0;
    if (actualCal > 0) diffPct = Math.round(((targetCal - actualCal) / actualCal) * 100);
    else diffPct = targetCal > 0 ? 100 : 0;

    if (diffPct < 0) captionEl.textContent = `Recommendation is ${Math.abs(diffPct)}% lower than your plate`;
    else if (diffPct > 0) captionEl.textContent = `Recommendation is ${diffPct}% higher than your plate`;
    else captionEl.textContent = 'Recommendation matches your plate';
  }, 800);
}

/* render only side items colored (used by both compares) */
function renderSideOnly(sideContainer, targetBase){
  sideContainer.innerHTML = '';
  const slots = computeSideSlots(targetBase.parentElement);
  (payload.positions || []).forEach(p => {
    if (p.placement !== 'side') return;
    const idx = (typeof p.sideSlot === 'number') ? p.sideSlot : 0;
    const chosen = slots[Math.min(idx, slots.length-1)] || {x:targetBase.parentElement.clientWidth-100,y:40};
    const si = document.createElement('div');
    si.className = 'sideItem';
    si.style.position = 'absolute';
    si.style.left = (chosen.x - 40) + 'px';
    si.style.top = (chosen.y - 20) + 'px';
    const src = p._imgOverride || resolveImage(p);
    si.innerHTML = `<img src="${escapeAttr(src)}" alt="${escapeAttr(p.label||p.id||'')}" style="width:100%;height:100%;object-fit:contain">`;
    sideContainer.appendChild(si);
  });
}

/* Clear compare */
function clearCompare(targetOverlay, targetBase, annNode, sideContainer, captionEl){
  targetOverlay.innerHTML = '';
  annNode.innerHTML = '';
  sideContainer.innerHTML = '';
  const plateArea = targetBase.querySelector('.plate-area');
  if (plateArea) {
    plateArea.style.transition = 'transform 300ms ease';
    plateArea.style.transform = 'translate(-50%,-50%) scale(1)';
  }
  Array.from(targetBase.querySelectorAll('.itemWrapper')).forEach(el => {
    if (el.dataset.onplate === '1') el.classList.remove('hidden-onplate');
  });
  captionEl.textContent = 'Comparison cleared. Template remains colored.';
}

/* UI wiring */
document.getElementById('backBtn').addEventListener('click', ()=> history.back());
document.getElementById('resetAllBtn').addEventListener('click', ()=> {
  clearCompare(overRec, baseRec, annRec, sideRec, capRec);
  clearCompare(overReal, baseReal, annReal, sideReal, capReal);
});

document.getElementById('cmpRecommendedBtn').addEventListener('click', ()=> {
  const recommendedMap = { carrot: 150, apple: 150, potato: 150, bread_variant: 0, sausage: 75, milk: 250, water: 0 };
  runCompare(overRec, baseRec, annRec, sideRec, capRec, recommendedMap, 'Recommended (Finland) vs Estimate');
});
document.getElementById('clearRecommendedBtn').addEventListener('click', ()=> clearCompare(overRec, baseRec, annRec, sideRec, capRec));

clearRealityBtn.addEventListener('click', ()=> clearCompare(overReal, baseReal, annReal, sideReal, capReal));

cmpRealityBtn.addEventListener('click', ()=> {
  const country = countrySelect.value;
  const info = latestKcalByCountry[country];
  if (!info || !info.kcal) { alert('No data for ' + country); return; }
  const dailyKcal = info.kcal;
  const lunchKcal = dailyKcal / 3;
  const lunchGrams = kcalToGrams(lunchKcal);
  const gramsMap = buildTargetGramsMap(lunchGrams);
  clearCompare(overReal, baseReal, annReal, sideReal, capReal);
  runCompare(overReal, baseReal, annReal, sideReal, capReal, gramsMap, `Reality vs Estimate (${country})`);
});

/* init: load payload from sessionStorage and OWID data then render */
(function init(){
  // load user plate payload
  const raw = sessionStorage.getItem(SESSION_KEY);
  if (!raw) {
    // fallback message
    baseRec.innerHTML = ''; baseReal.innerHTML = '';
    capRec.textContent = 'No saved plate found in sessionStorage under key: ' + SESSION_KEY;
    capReal.textContent = 'No saved plate found in sessionStorage under key: ' + SESSION_KEY;
  } else {
    try {
      payload = JSON.parse(raw);
    } catch(e){
      payload = null;
    }
    if (payload) {
      // normalize minimal fields used earlier
      (payload.positions || []).forEach(item => {
        if (typeof item.gramsPerPortion !== 'number') item.gramsPerPortion = item.gramsPerPortion || (DEFAULT_GRAMS[item.id] || 100);
        if (!('grams' in item) || item.grams == null) item.grams = item.grams || 0;
        if (item.gramsPerPortion && typeof item.grams === 'number') {
          const rawFrac = item.grams / item.gramsPerPortion;
          if (Math.abs(rawFrac - 0.5) < 0.02) item.fraction = 0.5;
          else item.fraction = Number(rawFrac.toFixed(3));
        } else item.fraction = item.fraction || 1;
      });
      renderBase(baseRec, sideRec);
      renderBase(baseReal, sideReal);
    }
  }

  // fetch OWID data and populate select
  fetchOwid().then(()=> {
    populateCountrySelect();
  }).catch(()=> {
    populateCountrySelect();
  });
})();
</script>
</body>
</html>
