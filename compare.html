<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Compare Plate — fixed shrink/growth ordering</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root { --plate-wrapper-size:520px; --plate-diameter:480px; }
  html,body{height:100%}
  body{font-family:Arial,system-ui,-apple-system,Segoe UI,Roboto;margin:14px;background:#f6f6f7;color:#222}
  .page{max-width:1200px;margin:0 auto}
  .topbar{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
  .btn{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#fff;cursor:pointer}
  .panels{display:flex;flex-direction:column;gap:36px;padding-bottom:120px}
  .panel{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 22px rgba(0,0,0,0.06)}
  .panelHeader{display:flex;gap:10px;align-items:center;margin-bottom:8px}
  .panelTitle{font-weight:600}
  .canvasRow{display:flex;gap:18px;align-items:flex-start}
  .plateCanvas{
    position:relative;
    width:var(--plate-wrapper-size);
    height:var(--plate-wrapper-size);
    background:#fff6e6;
    border:8px solid #eee;
    overflow:visible;
    padding:0;
    box-sizing:border-box;
    border-radius:50%;
    aspect-ratio:1/1;
  }
  .layer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;box-sizing:border-box}
  .sideColumn{position:absolute;top:14px;right:18px;display:flex;flex-direction:column;gap:10px;pointer-events:none}
  .sideColumn.left{right:auto;left:18px}
  .sideItem{width:86px;height:86px;display:flex;align-items:center;justify-content:center}
  .plateWrap {
    position:absolute;
    left:50%; top:50%;
    width:var(--plate-diameter); height:var(--plate-diameter);
    transform:translate(-50%,-50%) scale(1);
    transform-origin:50% 50%;
    border-radius:50%;
    pointer-events:none;
    box-sizing:border-box;
    aspect-ratio:1/1;
  }
  .plateInner { position:relative; width:100%; height:100%; border-radius:50%; box-sizing:border-box; }
  .ghostGroup, .ghostInnerGroup, .scaledGroup{
    position:absolute; left:0; top:0; width:100%; height:100%; transform-origin:50% 50%;
    pointer-events:none; overflow:visible; border-radius:50%; box-sizing:border-box;
  }
  .scaledGroup { z-index:10; }
  .ghostInnerGroup { z-index:12; pointer-events:none; }
  .ghostGroup { z-index:8; pointer-events:none; }
  .overlayFill{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); border-radius:50%; pointer-events:none; box-sizing:border-box;}
  .itemWrapper{position:absolute; transform:translate(-50%,-50%); pointer-events:none}
  .itemWrapper img{display:block;width:100%;height:100%;object-fit:contain}
  .ghost-img{filter:grayscale(100%) contrast(80%); opacity:0.45}
  .ghost-inner-img{filter:grayscale(100%) contrast(80%); opacity:0.9}
  .scaled-img{filter:none; opacity:1}
  .clip-half { -webkit-clip-path: polygon(0 0, 100% 100%, 0 100%); clip-path: polygon(0 0, 100% 100%, 0 100%); }
  .caption{font-size:13px;color:#333;margin-top:8px;max-width:420px}
  .annulus{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;pointer-events:none;opacity:0.95;box-sizing:border-box}
  .hidden-onplate { opacity:0; transform:scale(0.98); transition:opacity 220ms ease, transform 220ms ease; pointer-events:none; }
  .controlsRow{display:flex;gap:8px;align-items:center}
  select.countrySelect{padding:6px;border-radius:6px;border:1px solid #ccc;background:#fff}
  .note{font-size:12px;color:#666;margin-top:6px}
  @media (max-width:1000px){ :root{ --plate-wrapper-size:420px; --plate-diameter:380px; } .sideColumn{right:12px} }
</style>
</head>
<body>
  <div class="page">
    <div class="topbar">
      <div style="display:flex;gap:12px;align-items:center">
        <button id="backBtn" class="btn">Back</button>
        <div class="small" style="color:#444">Compare your plate to recommendation and to local OWID country lunch estimates</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="resetAllBtn" class="btn">Reset Comparisons</button>
      </div>
    </div>

    <div class="panels">
      <div class="panel">
        <div class="panelHeader">
          <div class="panelTitle">Compare to Recommended (Finland)</div>
          <div class="spacer"></div>
          <div class="controlsRow">
            <button id="cmpRecommendedBtn" class="btn">Run Compare</button>
            <button id="clearRecommendedBtn" class="btn">Clear</button>
          </div>
        </div>

        <div class="canvasRow" style="position:relative">
          <div class="plateCanvas" id="canvasRecommended">
            <div class="layer" id="baseRecommended"></div>
            <div class="layer" id="annulusRecommended"></div>
            <div class="layer" id="overlayRecommended"></div>
            <div class="sideColumn" id="sideRec"></div>
          </div>

          <div>
            <div class="caption" id="captionRecommended">Press Run Compare to scale the plate to Finnish recommendation.</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <div class="panelTitle">Compare to Reality (from local OWID files)</div>
          <div class="spacer"></div>
          <div class="controlsRow">
            <select id="countrySelect" class="countrySelect"></select>
            <button id="cmpRealityBtn" class="btn">Compare to Country</button>
            <button id="clearRealityBtn" class="btn">Clear</button>
          </div>
        </div>

        <div class="canvasRow" style="position:relative">
          <div class="plateCanvas" id="canvasReality">
            <div class="layer" id="baseReality"></div>
            <div class="layer" id="annulusReality"></div>
            <div class="layer" id="overlayReality"></div>
            <div class="sideColumn" id="sideReal"></div>
          </div>

          <div>
            <div class="caption" id="captionReality">Select a country and click Compare. Daily kcal (latest year) are divided by 3 for a lunch estimate.</div>
            <div class="note">Countries included: Finland, Sweden, Norway, Denmark, United States, Canada, Brazil, Argentina, Chile, China, India, Japan, Indonesia, Australia, New Zealand, Nigeria, Ethiopia, Kenya, South Africa, Egypt, Morocco</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Key fixes implemented:
 - For shrink (target scale < 1): show original-size ghost (grey) beneath and the smaller colored scaled items on top.
 - For growth (scale >= 1): show colored scaled items as larger with a smaller grey inner on top (ghost-inner) so grey appears inside colored.
 - Avoid accidental duplication: overlay elements are created once per payload position and we only toggle visibility/order at runCompare time; we also ensure overlays are cleared before building.
*/

const SESSION_KEY = 'plate_positions_fallback';
const LOCAL_CSV = 'daily-per-capita-caloric-supply.csv';
const LOCAL_META = 'daily-per-capita-caloric-supply.metadata.json';

const CAL_PER_G = { potato:0.77, sausage:2.5, carrot:0.41, bread_variant:2.5, bread:2.5, apple:0.52, orange:0.47, milk:0.64 };
const CATALOG_IMG = {
  potato:'images/potato.svg', sausage:'images/sausage.svg', carrot:'images/carrot.svg',
  bread_variant:'images/cheese-bread.svg', slice_of_bread:'images/slice-of-bread.svg', bread:'images/slice-of-bread.svg',
  apple:'images/apple.svg', milk:'images/milk-carton.svg'
};
const DEFAULT_GRAMS = { potato:150, sausage:75, carrot:75, bread:40, bread_variant:40, apple:150, milk:250 };

const COUNTRY_LIST = ["Finland","Sweden","Norway","Denmark","United States","Canada","Brazil","Argentina","Chile","China","India","Japan","Indonesia","Australia","New Zealand","Nigeria","Ethiopia","Kenya","South Africa","Egypt","Morocco"];

let payload = null;
let latestKcalByCountry = {};

const countrySelect = document.getElementById('countrySelect');
const cmpRealityBtn = document.getElementById('cmpRealityBtn');
const clearRealityBtn = document.getElementById('clearRealityBtn');

const baseRec = document.getElementById('baseRecommended');
const annRec  = document.getElementById('annulusRecommended');
const overRec = document.getElementById('overlayRecommended');
const sideRec = document.getElementById('sideRec');
const capRec  = document.getElementById('captionRecommended');

const baseReal = document.getElementById('baseReality');
const annReal  = document.getElementById('annulusReality');
const overReal = document.getElementById('overlayReality');
const sideReal = document.getElementById('sideReal');
const capReal  = document.getElementById('captionReality');

/* CSV parser */
function parseCsv(text){
  const rows=[]; let cur=[]; let curVal=''; let inQuotes=false;
  for (let i=0;i<text.length;i++){
    const ch=text[i], nxt=text[i+1];
    if (ch==='"') { if (inQuotes && nxt==='"'){ curVal+='"'; i++; continue; } inQuotes=!inQuotes; continue; }
    if (!inQuotes && (ch==='\n' || ch==='\r')) { if (ch==='\r' && text[i+1]==='\n') i++; cur.push(curVal); rows.push(cur); cur=[]; curVal=''; continue; }
    if (!inQuotes && ch===','){ cur.push(curVal); curVal=''; continue; }
    curVal+=ch;
  }
  if (curVal!==''||cur.length) cur.push(curVal);
  if (cur.length) rows.push(cur);
  if (!rows.length) return { header:[], rows:[] };
  const header = rows[0].map(h=>h.trim());
  const data = rows.slice(1).map(r=>{ const o={}; for(let j=0;j<header.length;j++) o[header[j]] = r[j]!==undefined? r[j] : ''; return o; });
  return { header, rows:data };
}

/* load local OWID CSV + metadata */
async function loadLocalOwid(){
  latestKcalByCountry = {};
  try {
    const [metaRes,csvRes] = await Promise.all([fetch(LOCAL_META), fetch(LOCAL_CSV)]);
    if (!metaRes.ok || !csvRes.ok) throw new Error('fetch failed');
    const meta = await metaRes.json();
    const csvText = await csvRes.text();
    const parsed = parseCsv(csvText);

    const countryCol = parsed.header.find(h => /country|entity|name/i.test(h)) || parsed.header[0];
    const yearCol = parsed.header.find(h => /year/i.test(h)) || parsed.header[1];

    let valueCol = null;
    if (meta && meta.variables && Array.isArray(meta.variables)) {
      const candidate = meta.variables.find(v => v.dataColumn || v.column || v.name);
      if (candidate) valueCol = candidate.dataColumn || candidate.column || candidate.name;
    }
    if (!valueCol) {
      const lc = parsed.header.map(h => h.toLowerCase());
      const candidates = ['daily supply of calories per person','daily-per-capita-caloric-supply','value','daily supply','calories'];
      for (const c of candidates) { const idx = lc.findIndex(h=>h.includes(c)); if (idx !== -1){ valueCol = parsed.header[idx]; break; } }
    }
    if (!valueCol && parsed.rows.length) {
      const sample = parsed.rows[0];
      for (const k of Object.keys(sample)){ if (k===countryCol||k===yearCol) continue; const v = sample[k]; if (v!=='' && !isNaN(Number(v))){ valueCol = k; break; } }
    }

    const byCountry = {};
    parsed.rows.forEach(r=>{
      const country = (r[countryCol]||'').trim(); const year = Number(r[yearCol]);
      const v = valueCol ? (r[valueCol]===''? NaN : Number(r[valueCol])) : NaN;
      if (!country || !year || isNaN(v)) return;
      if (!byCountry[country]) byCountry[country] = {};
      byCountry[country][year] = v;
    });

    COUNTRY_LIST.forEach(c=>{
      const data = byCountry[c];
      if (!data) { latestKcalByCountry[c] = null; return; }
      const yrs = Object.keys(data).map(Number).filter(y=>!isNaN(y));
      if (!yrs.length) { latestKcalByCountry[c]=null; return; }
      const latest = Math.max(...yrs);
      latestKcalByCountry[c] = { year: latest, kcal: data[latest] };
    });
    return true;
  } catch (e) {
    console.error('OWID load error', e);
    COUNTRY_LIST.forEach(c => latestKcalByCountry[c] = null);
    return false;
  }
}

function populateCountrySelect(){
  countrySelect.innerHTML = '';
  COUNTRY_LIST.forEach(c => {
    const info = latestKcalByCountry[c];
    const opt = document.createElement('option');
    opt.value = c;
    opt.textContent = info && info.kcal ? `${c} — ${Math.round(info.kcal)} kcal/day (${info.year})` : `${c} — (no data)`;
    countrySelect.appendChild(opt);
  });
}

function escapeAttr(s){ return String(s||'').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function resolveImage(p){ if (p._imgOverride) return p._imgOverride; if (p.id === 'bread_variant') return CATALOG_IMG.bread_variant; if (p.id && CATALOG_IMG[p.id]) return CATALOG_IMG[p.id]; return 'images/' + (p.id || 'unknown') + '.svg'; }

function computeSideSlots(canvasEl){
  const rect = canvasEl.getBoundingClientRect();
  const plateDiameter = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--plate-diameter')) || 480;
  const plateRight = (rect.width/2) + (plateDiameter/2);
  const gap = Math.max(8, Math.round(Math.min(rect.width, rect.height) * 0.02));
  const columnX = Math.min(rect.width - 30, Math.round(plateRight + gap));
  const startY = 40; const spacing = 18 + 86;
  const slots = []; const max = Math.max(4, Math.floor((rect.height - startY - 20) / spacing));
  for (let i=0;i<max;i++) slots.push({ x: columnX, y: startY + i * spacing });
  return slots;
}

/* Render base plate (plateWrap + plateInner) */
function renderBase(targetBase, sideContainer){
  targetBase.innerHTML = ''; sideContainer.innerHTML = '';
  const wrap = document.createElement('div'); wrap.className='plateWrap';
  const inner = document.createElement('div'); inner.className='plateInner'; wrap.appendChild(inner); targetBase.appendChild(wrap);
  const slots = computeSideSlots(targetBase.parentElement);
  (payload.positions||[]).forEach(p=>{
    if (p.placement === 'side') {
      const idx = typeof p.sideSlot === 'number' ? p.sideSlot : 0;
      const chosen = slots[Math.min(idx, slots.length-1)] || {x:targetBase.parentElement.clientWidth-100,y:40};
      const si = document.createElement('div'); si.className='sideItem'; si.style.position='absolute';
      si.style.left=(chosen.x-40)+'px'; si.style.top=(chosen.y-20)+'px';
      const src = p._imgOverride || resolveImage(p);
      si.innerHTML = `<img src="${escapeAttr(src)}" alt="${escapeAttr(p.label||p.id||'')}" style="width:100%;height:100%;object-fit:contain">`;
      sideContainer.appendChild(si); return;
    }
    const w = document.createElement('div'); w.className='itemWrapper'; w.dataset.onplate='1';
    w.style.position='absolute'; w.style.left=(p.x||0)+'px'; w.style.top=(p.y||0)+'px';
    w.style.width=(p.sizePx||48)+'px'; w.style.height=(p.sizePx||48)+'px';
    w.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    const img = document.createElement('img'); img.src=p._imgOverride||resolveImage(p); img.alt=p.label||p.id||'';
    const frac = typeof p.fraction === 'number' ? p.fraction : 1;
    if (Math.abs(frac - 0.5) < 0.001) img.classList.add('clip-half');
    else if (frac < 0.5) img.style.transform = `scale(${Math.max(0.25, Math.min(1, frac))})`;
    w.appendChild(img); inner.appendChild(w);
  });
}

/* Build overlay once per panel. It creates three groups (ghost, scaled, ghostInner) with one element per payload position.
   We do NOT duplicate items anywhere else; runCompare will decide which groups are visible/stacked depending on scale.
*/
function buildOverlay(targetOverlay){
  targetOverlay.innerHTML = '';
  const wrap = document.createElement('div'); wrap.className='plateWrap';
  const ghost = document.createElement('div'); ghost.className='ghostGroup';
  const scaled = document.createElement('div'); scaled.className='scaledGroup';
  const ghostInner = document.createElement('div'); ghostInner.className='ghostInnerGroup';

  (payload.positions||[]).forEach((p, idx) => {
    if (p.placement !== 'onplate') return;

    // ghost (full-size grey) — exactly one per position
    const gw = document.createElement('div'); gw.className='itemWrapper';
    gw.style.position='absolute'; gw.style.left=(p.x||0)+'px'; gw.style.top=(p.y||0)+'px';
    gw.style.width=(p.sizePx||48)+'px'; gw.style.height=(p.sizePx||48)+'px';
    gw.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    const gimg = document.createElement('img'); gimg.src = p._imgOverride || resolveImage(p); gimg.alt = p.label||p.id||'';
    gimg.dataset.role = 'ghost'; gimg.className='ghost-img'; gw.appendChild(gimg); ghost.appendChild(gw);

    // scaled (colored) — one per position; scaled transform applied later in runCompare
    const sw = document.createElement('div'); sw.className='itemWrapper';
    sw.style.position='absolute'; sw.style.left=(p.x||0)+'px'; sw.style.top=(p.y||0)+'px';
    sw.style.width=(p.sizePx||48)+'px'; sw.style.height=(p.sizePx||48)+'px';
    sw.dataset.rotate = (p.rotationDeg||0);
    // default transform is centered; runCompare will set scale/rotation
    sw.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg) scale(1)`;
    const simg = document.createElement('img'); simg.src = p._imgOverride || resolveImage(p); simg.alt = p.label||p.id||'';
    simg.dataset.role = 'scaled'; simg.className='scaled-img'; sw.appendChild(simg); scaled.appendChild(sw);

    // ghost-inner (smaller grey) — one per position, used for growth case (appears on top of colored)
    const giw = document.createElement('div'); giw.className='itemWrapper';
    giw.style.position='absolute'; giw.style.left=(p.x||0)+'px'; giw.style.top=(p.y||0)+'px';
    giw.style.width=(p.sizePx||48)+'px'; giw.style.height=(p.sizePx||48)+'px';
    // initial small scale; runCompare may adjust visibility
    const innerScale = 0.72;
    giw.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg) scale(${innerScale})`;
    const giimg = document.createElement('img'); giimg.src = p._imgOverride || resolveImage(p); giimg.alt = p.label||p.id||'';
    giimg.dataset.role = 'ghostInner'; giimg.className='ghost-inner-img';
    giw.appendChild(giimg); ghostInner.appendChild(giw);
  });

  // order within wrap: ghost (back), scaled (middle), ghostInner (top)
  wrap.appendChild(ghost); wrap.appendChild(scaled); wrap.appendChild(ghostInner);
  targetOverlay.appendChild(wrap);

  // store refs for runCompare
  targetOverlay._wrap = wrap;
  targetOverlay._ghost = ghost;
  targetOverlay._scaled = scaled;
  targetOverlay._ghostInner = ghostInner;
}

/* Annulus and mini-plate */
function drawAnnulus(node, scale){
  node.innerHTML = '';
  if (!scale || isNaN(scale)) return;
  const base = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--plate-diameter')) || 480;
  const scaled = Math.max(2, Math.round(base * scale));
  if (scale >= 1) {
    const ann = document.createElement('div'); ann.className='annulus';
    ann.style.position='absolute'; ann.style.left='50%'; ann.style.top='50%'; ann.style.transform='translate(-50%,-50%)';
    ann.style.boxSizing='border-box';
    const outer = scaled; const thickness = Math.max(4, Math.round((scaled - base) / 2));
    ann.style.width = outer + 'px'; ann.style.height = outer + 'px';
    ann.style.border = `${thickness}px solid rgba(88,196,104,0.95)`; node.appendChild(ann);
  } else {
    const fill = document.createElement('div'); fill.className='overlayFill';
    fill.style.width = scaled + 'px'; fill.style.height = scaled + 'px';
    fill.style.background = 'rgba(220,70,70,0.22)'; fill.style.border='1px solid rgba(220,70,70,0.28)';
    fill.style.left='50%'; fill.style.top='50%'; fill.style.position='absolute'; fill.style.transform='translate(-50%,-50%)';
    fill.style.boxSizing='border-box'; node.appendChild(fill);
    const rim = document.createElement('div'); rim.className='annulus';
    rim.style.position='absolute'; rim.style.left='50%'; rim.style.top='50%'; rim.style.transform='translate(-50%,-50%)';
    rim.style.boxSizing='border-box';
    const outer = scaled; const thickness = Math.max(2, Math.round(outer * 0.02));
    rim.style.width = outer + 'px'; rim.style.height = outer + 'px';
    rim.style.border = `${thickness}px solid rgba(220,70,70,0.22)`; node.appendChild(rim);
  }
}

/* calories/grams helpers */
const avgKcalPerGram = 1.5;
function kcalToGrams(kcal){ return Math.max(0, Math.round(kcal / avgKcalPerGram)); }
function buildTargetGramsMap(totalGrams){
  const idsPreferred = ['potato','carrot','bread_variant','sausage','apple','milk'];
  const weights = [1.3,1,1.1,0.9,0.9,1.0];
  const totalW = weights.reduce((s,w)=>s+w,0);
  const map = {}; let remaining = totalGrams;
  idsPreferred.forEach((id,i)=>{ const g = Math.round((weights[i]/totalW) * totalGrams); map[id]=g; remaining-=g; });
  let i =0; while (remaining>0){ const key = idsPreferred[i%idsPreferred.length]; map[key]=(map[key]||0)+1; remaining--; i++; }
  return map;
}
function totalCaloriesFromMap(map){ let sum=0; Object.keys(map||{}).forEach(id=>{ const grams = map[id]||0; const calPerG = CAL_PER_G[id]!==undefined?CAL_PER_G[id]:0.8; sum+=grams*calPerG; }); return sum; }
function totalCaloriesPayloadFromPositions(positions){ return (positions||[]).reduce((s,p)=>{ if (typeof p.kcalPerPortion==='number' && typeof p.gramsPerPortion==='number' && p.gramsPerPortion>0){ const calPerG = p.kcalPerPortion / p.gramsPerPortion; return s + (p.grams||0) * calPerG; } const calPerG = CAL_PER_G[p.id] !== undefined ? CAL_PER_G[p.id] : 0.8; return s + (p.grams||0) * calPerG; }, 0); }
function totalCaloriesPayload(){ if (payload && typeof payload.totalCalories === 'number') return Math.max(0, Math.round(payload.totalCalories)); return Math.max(0, Math.round(totalCaloriesPayloadFromPositions(payload.positions||[]))); }

function computeScaleFromCalories(targetMap){
  const actual = Math.max(1, totalCaloriesPayload());
  const target = Math.max(0, totalCaloriesFromMap(targetMap||{}));
  if (target <= 0) return 0.001;
  return Math.max(0.12, Math.min(3.0, Math.sqrt(target / actual)));
}
function placeSideColumn(sideContainer, toRight){ if (!sideContainer) return; sideContainer.classList.remove('left'); if (!toRight) sideContainer.classList.add('left'); }

/* runCompare: key behavior
   - build overlay (ghost, scaled, ghostInner) once
   - if scale < 1 (shrink): show ghost (full-size grey) as back layer, show scaled (smaller colored) on top, hide ghostInner.
     scaled items get transform scale = scale.
   - if scale >= 1 (growth): show scaled (larger colored) as middle layer with transform scale = scale, and show ghostInner (small grey) ON TOP.
     ghost (full-size) remains visible beneath but subdued.
*/
function runCompare(targetOverlay, targetBase, annNode, sideContainer, captionEl, targetMap){
  if (!payload) { alert('No saved plate'); return; }
  targetOverlay.innerHTML=''; annNode.innerHTML=''; sideContainer.innerHTML='';
  renderSideOnly(sideContainer, targetBase);
  buildOverlay(targetOverlay);

  const scale = computeScaleFromCalories(targetMap);
  // scale the plate wrapper
  const wrap = targetBase.querySelector('.plateWrap');
  if (wrap){ wrap.style.transition = 'transform 700ms cubic-bezier(.2,.9,.2,1)'; requestAnimationFrame(()=> wrap.style.transform = `translate(-50%,-50%) scale(${scale})`); }

  drawAnnulus(annNode, scale);

  const ghostGroup = targetOverlay._ghost;
  const scaledGroup = targetOverlay._scaled;
  const ghostInnerGroup = targetOverlay._ghostInner;

  // Reset display
  if (ghostGroup) ghostGroup.style.display = '';
  if (scaledGroup) scaledGroup.style.display = '';
  if (ghostInnerGroup) ghostInnerGroup.style.display = '';

  if (scale < 1) {
    // SHRINK case: original (ghostGroup) should appear big grey BELOW, scaled colored smaller ON TOP.
    // Ensure ghostInner is hidden; ghost full-size visible but desaturated.
    if (ghostInnerGroup) ghostInnerGroup.style.display = 'none';
    if (ghostGroup) {
      Array.from(ghostGroup.querySelectorAll('.itemWrapper')).forEach(w => {
        const img = w.querySelector('img'); if (img) img.className = 'ghost-img';
        w.style.transform = w.style.transform; // keep original transform (full-size)
      });
      ghostGroup.style.opacity = '0.65';
    }
    if (scaledGroup) {
      Array.from(scaledGroup.querySelectorAll('.itemWrapper')).forEach(sw => {
        const rotate = Number(sw.dataset.rotate || 0);
        sw.style.transition = 'transform 700ms cubic-bezier(.2,.9,.2,1)';
        // scaledGroup items should be smaller than ghost: apply overall scale
        requestAnimationFrame(()=> sw.style.transform = `translate(-50%,-50%) rotate(${rotate}deg) scale(${scale})`);
      });
    }
  } else {
    // GROWTH case: scaled items become larger colored background, ghostInner (smaller grey) sits on top (inner grey inside colored)
    if (ghostInnerGroup) ghostInnerGroup.style.display = '';
    if (ghostGroup) {
      // keep ghost as subtle background
      Array.from(ghostGroup.querySelectorAll('.itemWrapper')).forEach(w => {
        const img = w.querySelector('img'); if (img) img.className = 'ghost-img';
      });
      ghostGroup.style.opacity = '0.35';
    }
    if (scaledGroup) {
      Array.from(scaledGroup.querySelectorAll('.itemWrapper')).forEach(sw => {
        const rotate = Number(sw.dataset.rotate || 0);
        sw.style.transition = 'transform 700ms cubic-bezier(.2,.9,.2,1)';
        requestAnimationFrame(()=> sw.style.transform = `translate(-50%,-50%) rotate(${rotate}deg) scale(${scale})`);
      });
    }
    // ghostInner should remain at its precomputed inner scale so it looks like grey inside colored
    if (ghostInnerGroup) {
      Array.from(ghostInnerGroup.querySelectorAll('.itemWrapper')).forEach(giw => {
        // ensure inner remains small and visible
        giw.style.transition = 'opacity 300ms ease';
        giw.style.opacity = '1';
      });
    }
  }

  // hide original base on-plate items (we keep ghost overlay visible instead)
  Array.from(targetBase.querySelectorAll('.itemWrapper')).forEach(el => { if (el.dataset.onplate === '1') el.classList.add('hidden-onplate'); });

  // side column placement and caption
  const actualCal = Math.round(totalCaloriesPayload());
  const targetCal = Math.round(totalCaloriesFromMap(targetMap||{}));
  placeSideColumn(sideContainer, targetCal >= actualCal);

  setTimeout(()=> {
    let diffPct = 0;
    if (actualCal > 0) diffPct = Math.round(((targetCal - actualCal) / actualCal) * 100);
    else diffPct = targetCal > 0 ? 100 : 0;
    if (diffPct < 0) captionEl.textContent = `Recommendation is ${Math.abs(diffPct)}% lower than your plate`;
    else if (diffPct > 0) captionEl.textContent = `Recommendation is ${diffPct}% higher than your plate`;
    else captionEl.textContent = 'Recommendation matches your plate';
  }, 800);
}

/* render side items (colored) */
function renderSideOnly(sideContainer, targetBase){
  sideContainer.innerHTML = ''; const slots = computeSideSlots(targetBase.parentElement);
  (payload.positions||[]).forEach(p=>{
    if (p.placement !== 'side') return;
    const idx = (typeof p.sideSlot === 'number') ? p.sideSlot : 0;
    const chosen = slots[Math.min(idx, slots.length-1)] || {x:targetBase.parentElement.clientWidth-100,y:40};
    const si = document.createElement('div'); si.className='sideItem'; si.style.position='absolute';
    si.style.left=(chosen.x-40)+'px'; si.style.top=(chosen.y-20)+'px';
    const src = p._imgOverride || resolveImage(p);
    si.innerHTML = `<img src="${escapeAttr(src)}" alt="${escapeAttr(p.label||p.id||'')}" style="width:100%;height:100%;object-fit:contain">`;
    sideContainer.appendChild(si);
  });
}

/* clearing */
function clearCompare(targetOverlay, targetBase, annNode, sideContainer, captionEl){
  targetOverlay.innerHTML=''; annNode.innerHTML=''; sideContainer.innerHTML='';
  const wrap = targetBase.querySelector('.plateWrap');
  if (wrap){ wrap.style.transition='transform 300ms ease'; wrap.style.transform='translate(-50%,-50%) scale(1)'; }
  Array.from(targetBase.querySelectorAll('.itemWrapper')).forEach(el => { if (el.dataset.onplate === '1') el.classList.remove('hidden-onplate'); });
  captionEl.textContent = 'Comparison cleared. Template remains colored.';
}

/* helpers for calories */
const avgKcalPerGram = 1.5;
function kcalToGrams(kcal){ return Math.max(0, Math.round(kcal / avgKcalPerGram)); }
function totalCaloriesFromMap(map){ let s=0; Object.keys(map||{}).forEach(k=>{ const g=map[k]||0; const c = CAL_PER_G[k]!==undefined?CAL_PER_G[k]:0.8; s+=g*c; }); return s; }
function totalCaloriesPayloadFromPositions(positions){ return (positions||[]).reduce((s,p)=>{ if (typeof p.kcalPerPortion==='number'&&typeof p.gramsPerPortion==='number'&&p.gramsPerPortion>0){ const calPerG = p.kcalPerPortion/p.gramsPerPortion; return s + (p.grams||0)*calPerG; } const calPerG = CAL_PER_G[p.id]!==undefined?CAL_PER_G[p.id]:0.8; return s + (p.grams||0)*calPerG; }, 0); }
function totalCaloriesPayload(){ if (payload && typeof payload.totalCalories === 'number') return Math.max(0, Math.round(payload.totalCalories)); return Math.max(0, Math.round(totalCaloriesPayloadFromPositions(payload.positions||[]))); }
function buildTargetGramsMap(totalGrams){ const ids=['potato','carrot','bread_variant','sausage','apple','milk']; const weights=[1.3,1,1.1,0.9,0.9,1]; const totalW=weights.reduce((a,b)=>a+b,0); const map={}; let rem=totalGrams; ids.forEach((id,i)=>{ const g=Math.round((weights[i]/totalW)*totalGrams); map[id]=g; rem-=g; }); let i=0; while(rem>0){ const k=ids[i%ids.length]; map[k]=(map[k]||0)+1; rem--; i++; } return map; }

/* UI wiring & init */
document.getElementById('backBtn').addEventListener('click', ()=> history.back());
document.getElementById('resetAllBtn').addEventListener('click', ()=> { clearCompare(overRec, baseRec, annRec, sideRec, capRec); clearCompare(overReal, baseReal, annReal, sideReal, capReal); });

document.getElementById('cmpRecommendedBtn').addEventListener('click', ()=> {
  const recommendedMap = { carrot:150, apple:150, potato:150, bread_variant:0, sausage:75, milk:250, water:0 };
  runCompare(overRec, baseRec, annRec, sideRec, capRec, recommendedMap);
});
document.getElementById('clearRecommendedBtn').addEventListener('click', ()=> clearCompare(overRec, baseRec, annRec, sideRec, capRec));

clearRealityBtn.addEventListener('click', ()=> clearCompare(overReal, baseReal, annReal, sideReal, capReal));

cmpRealityBtn.addEventListener('click', ()=> {
  const country = countrySelect.value;
  const info = latestKcalByCountry[country];
  if (!info || !info.kcal) { alert('No data for ' + country); return; }
  const dailyKcal = info.kcal; const lunchKcal = dailyKcal/3; const lunchGrams = kcalToGrams(lunchKcal);
  const gramsMap = buildTargetGramsMap(lunchGrams);
  runCompare(overReal, baseReal, annReal, sideReal, capReal, gramsMap);
});

/* load payload + local OWID data */
(async function init(){
  try { const raw = sessionStorage.getItem(SESSION_KEY); if (raw) payload = JSON.parse(raw); } catch(e){ payload=null; }
  if (payload) {
    (payload.positions||[]).forEach(item => {
      if (typeof item.gramsPerPortion !== 'number') item.gramsPerPortion = item.gramsPerPortion || (DEFAULT_GRAMS[item.id]||100);
      if (!('grams' in item) || item.grams==null) item.grams = item.grams || 0;
      if (item.gramsPerPortion && typeof item.grams === 'number'){ const rawf = item.grams / item.gramsPerPortion; item.fraction = Number(Math.max(0,Math.min(1,rawf)).toFixed(3)); } else item.fraction = item.fraction || 1;
    });
    renderBase(baseRec, sideRec);
    renderBase(baseReal, sideReal);
  } else {
    baseRec.innerHTML=''; baseReal.innerHTML='';
    capRec.textContent = 'No saved plate in sessionStorage under key: ' + SESSION_KEY;
    capReal.textContent = 'No saved plate in sessionStorage under key: ' + SESSION_KEY;
  }
  await loadLocalOwid();
  populateCountrySelect();
})();

/* loadLocalOwid / populateCountrySelect reused from earlier code (omitted here for brevity) */
/* For completeness we reinsert them below so this is a standalone file. */

async function loadLocalOwid(){ latestKcalByCountry={}; try{ const [metaRes,csvRes] = await Promise.all([fetch(LOCAL_META), fetch(LOCAL_CSV)]); if(!metaRes.ok||!csvRes.ok) throw new Error('fetch failed'); const meta = await metaRes.json(); const csvText = await csvRes.text(); const parsed = parseCsv(csvText); const countryCol = parsed.header.find(h=>/country|entity|name/i.test(h))||parsed.header[0]; const yearCol = parsed.header.find(h=>/year/i.test(h))||parsed.header[1]; let valueCol=null; if(meta&&meta.variables&&Array.isArray(meta.variables)){ const candidate = meta.variables.find(v=>v.dataColumn||v.column||v.name); if(candidate) valueCol = candidate.dataColumn||candidate.column||candidate.name; } if(!valueCol){ const lc = parsed.header.map(h=>h.toLowerCase()); const candidates = ['daily supply of calories per person','daily-per-capita-caloric-supply','value','daily supply','calories']; for(const c of candidates){ const idx = lc.findIndex(h=>h.includes(c)); if(idx!==-1){ valueCol = parsed.header[idx]; break; } } } if(!valueCol && parsed.rows.length){ const sample = parsed.rows[0]; for(const k of Object.keys(sample)){ if(k===countryCol||k===yearCol) continue; const v = sample[k]; if(v!=='' && !isNaN(Number(v))){ valueCol = k; break; } } } const byCountry={}; parsed.rows.forEach(r=>{ const country = (r[countryCol]||'').trim(); const year = Number(r[yearCol]); const v = valueCol ? (r[valueCol]===''?NaN:Number(r[valueCol])) : NaN; if(!country||!year||isNaN(v)) return; if(!byCountry[country]) byCountry[country] = {}; byCountry[country][year] = v; }); COUNTRY_LIST.forEach(c=>{ const data = byCountry[c]; if(!data){ latestKcalByCountry[c]=null; return; } const yrs = Object.keys(data).map(Number).filter(y=>!isNaN(y)); if(!yrs.length){ latestKcalByCountry[c]=null; return; } const latest = Math.max(...yrs); latestKcalByCountry[c] = { year: latest, kcal: data[latest] }; }); return true; } catch(e){ console.error('OWID load error', e); COUNTRY_LIST.forEach(c=> latestKcalByCountry[c]=null); return false; } }
function populateCountrySelect(){ countrySelect.innerHTML=''; COUNTRY_LIST.forEach(c=>{ const info = latestKcalByCountry[c]; const opt = document.createElement('option'); opt.value = c; opt.textContent = info && info.kcal ? `${c} — ${Math.round(info.kcal)} kcal/day (${info.year})` : `${c} — (no data)`; countrySelect.appendChild(opt); }); }

</script>
</body>
</html>
