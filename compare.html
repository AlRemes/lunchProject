<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Compare Plate — scale by total calories</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root {
    --canvas-size: 760px;
    --plate-pct: 72%;
    --overlay-baseline: 0.92;
  }
  body{font-family:Arial;margin:14px;background:#f6f6f7}
  .page{max-width:1200px;margin:0 auto}
  .topbar{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
  .btn{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#fff;cursor:pointer}
  .panels{display:flex;flex-direction:column;gap:36px;padding-bottom:120px}
  .panel{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 22px rgba(0,0,0,0.06)}
  .panelHeader{display:flex;gap:10px;align-items:center;margin-bottom:8px}
  .panelTitle{font-weight:600}
  .canvasRow{display:flex;gap:18px;align-items:flex-start}
  .plateCanvas{position:relative;width:var(--canvas-size);height:var(--canvas-size);background:#fff6e6;border:8px solid #eee;overflow:visible;padding:80px;box-sizing:border-box;border-radius:50%}
  .layer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
  .scaledContainer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:visible}
  .scaledGroup{position:absolute;left:50%;top:50%;width:var(--plate-pct);height:var(--plate-pct);transform:translate(-50%,-50%) scale(var(--overlay-baseline));transform-origin:50% 50%;pointer-events:none;overflow:visible}
  .scaledSvg{position:absolute;left:0;top:0;width:100%;height:100%}
  .itemWrapper{position:absolute; transform:translate(-50%,-50%); pointer-events:none}
  .itemWrapper img{display:block;width:100%;height:100%;object-fit:contain}
  .clip-half { -webkit-clip-path: polygon(0 0, 100% 100%, 0 100%); clip-path: polygon(0 0, 100% 100%, 0 100%); }
  .caption{font-size:13px;color:#333;margin-top:8px;max-width:360px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .spacer{flex:1}
  .annulus{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;pointer-events:none;opacity:0.9;box-sizing:border-box}
  .hidden-onplate { opacity:0; transform:scale(0.98); transition:opacity 220ms ease, transform 220ms ease; pointer-events:none; }
  @media (max-width:1000px){ :root{--canvas-size:560px} .plateCanvas{padding:44px} .scaledGroup{width:78%;height:78%} }
</style>
</head>
<body>
  <div class="page">
    <div class="topbar">
      <div style="display:flex;gap:12px;align-items:center">
        <button id="backBtn" class="btn">Back</button>
        <div class="small" style="color:#444">Template: your saved plate (colored). Use panels below to compare by calories.</div>
      </div>
      <div style="display:flex;gap:8px">
        <button id="resetAllBtn" class="btn">Reset Comparisons</button>
      </div>
    </div>

    <div class="panels">
      <div class="panel">
        <div class="panelHeader">
          <div class="panelTitle">Compare to Recommended (Finland)</div>
          <div class="spacer"></div>
          <div class="controls">
            <button id="cmpRecommendedBtn" class="btn">Run Compare</button>
            <button id="clearRecommendedBtn" class="btn">Clear</button>
          </div>
        </div>

        <div class="canvasRow">
          <div class="plateCanvas" id="canvasRecommended">
            <div class="layer" id="baseRecommended"></div>
            <div class="layer" id="annulusRecommended"></div>
            <div class="layer" id="overlayRecommended"></div>
          </div>

          <div>
            <div class="caption" id="captionRecommended">Press Run Compare to scale the plate based on total calories (user plate vs recommended). The annulus shows growth (green) or shrink (red).</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <div class="panelTitle">Compare to Reality (custom)</div>
          <div class="spacer"></div>
          <div class="controls">
            <button id="cmpRealityBtn" class="btn">Run Compare</button>
            <button id="clearRealityBtn" class="btn">Clear</button>
          </div>
        </div>

        <div class="canvasRow">
          <div class="plateCanvas" id="canvasReality">
            <div class="layer" id="baseReality"></div>
            <div class="layer" id="annulusReality"></div>
            <div class="layer" id="overlayReality"></div>
          </div>

          <div>
            <div class="caption" id="captionReality">Custom comparison. Enter a target grams mapping (or use recommended) when prompted.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
 - Scale determined by total calories: scale = sqrt(targetCalories / actualCalories)
 - Uses payload.totalCalories (provided by index.html) when present, otherwise falls back to computing from grams
 - caloriesPerGram mapping provided; adjust values if your dataset uses different foods
 - overlay scaledGroup contains on-plate items and SVG circle so the plate remains circular
 - base on-plate items hidden while overlay is active to avoid duplicate appearance
*/

const SESSION_KEY = 'plate_positions_fallback';

// calories per gram (kcal/g). Edit if you have better per-item numbers.
const CAL_PER_G = {
  potato: 0.77,
  sausage: 2.5,
  carrot: 0.41,
  bread_variant: 2.5,
  bread: 2.5,
  apple: 0.52,
  orange: 0.47,
  milk: 0.64,
  water: 0.0
};

// image/catalog fallback (used for rendering)
const CATALOG_IMG = {
  potato: 'images/potato.svg',
  sausage: 'images/sausage.svg',
  carrot: 'images/carrot.svg',
  bread_variant: 'images/slice-of-bread.svg',
  bread: 'images/slice-of-bread.svg',
  apple: 'images/apple.svg',
  orange: 'images/orange.svg',
  milk: 'images/milk-carton.svg',
  water: 'images/glass-of-water.svg'
};

let payload = null;

// DOM refs
const baseRec = document.getElementById('baseRecommended');
const annRec  = document.getElementById('annulusRecommended');
const overRec = document.getElementById('overlayRecommended');
const capRec  = document.getElementById('captionRecommended');

const baseReal = document.getElementById('baseReality');
const annReal  = document.getElementById('annulusReality');
const overReal = document.getElementById('overlayReality');
const capReal  = document.getElementById('captionReality');

function loadPayload(){
  const raw = sessionStorage.getItem(SESSION_KEY);
  if (!raw) return null;
  try { return JSON.parse(raw); } catch(e){ return null; }
}

function normalizePayload(p){
  (p.positions || []).forEach(item => {
    if (!item.gramsPerPortion) item.gramsPerPortion = item.gramsPerPortion || 100;
    if (!('grams' in item) || item.grams == null) {
      if ('fraction' in item && item.fraction && item.gramsPerPortion) item.grams = Math.round(item.fraction * item.gramsPerPortion);
      else item.grams = item.gramsPerPortion || 0;
    }
    if (item.gramsPerPortion && item.grams) item.fraction = Math.round((item.grams / item.gramsPerPortion) * 100) / 100;
    if (Math.abs((item.fraction || 0) - 0.5) < 0.02) item.fraction = 0.5;
  });

  // ensure totalCalories exists and is numeric; keep it if provided from index.html
  if (!('totalCalories' in p) || typeof p.totalCalories !== 'number') {
    p.totalCalories = totalCaloriesPayloadFromPositions(p.positions || []);
  }
}

// Render base layer (colored). mark on-plate with data-onplate so they can be hidden when overlay active.
function renderBase(targetBase){
  targetBase.innerHTML = '';
  const plateBg = document.createElement('div');
  plateBg.style.position='absolute';
  plateBg.style.left='50%'; plateBg.style.top='50%';
  plateBg.style.width='var(--plate-pct)'; plateBg.style.height='var(--plate-pct)';
  plateBg.style.transform='translate(-50%,-50%)';
  plateBg.style.borderRadius='50%';
  plateBg.style.background='transparent';
  targetBase.appendChild(plateBg);

  (payload.positions || []).forEach(p => {
    const w = document.createElement('div');
    w.className = 'itemWrapper';
    w.dataset.onplate = p.placement === 'onplate' ? '1' : '0';
    w.style.left = (p.x||0) + 'px';
    w.style.top = (p.y||0) + 'px';
    w.style.width = (p.sizePx||48) + 'px';
    w.style.height = (p.sizePx||48) + 'px';
    w.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    const img = document.createElement('img');
    img.src = (p._imgOverride || CATALOG_IMG[p.id] || ('images/' + (p.id || 'unknown') + '.svg'));
    img.alt = p.label || p.id || '';
    img.classList.remove('clip-half'); img.style.transform = '';
    const frac = p.fraction || 1;
    if (Math.abs(frac - 0.5) < 0.001) img.classList.add('clip-half');
    else if (frac < 0.5) img.style.transform = `scale(${Math.max(0.25, Math.min(1, frac))})`;
    img.style.filter = '';
    w.appendChild(img);
    targetBase.appendChild(w);
  });
}

// Build scaled overlay: scaledContainer covers canvas; scaledGroup centered and sized to --plate-pct; scaledGroup contains SVG circle + on-plate items placed at same px coords.
function buildScaledOverlay(targetOverlay){
  targetOverlay.innerHTML = '';
  const scaledContainer = document.createElement('div');
  scaledContainer.className = 'scaledContainer';
  scaledContainer.style.position='absolute'; scaledContainer.style.left='0'; scaledContainer.style.top='0';
  scaledContainer.style.width='100%'; scaledContainer.style.height='100%';

  const scaledGroup = document.createElement('div');
  scaledGroup.className = 'scaledGroup';
  scaledGroup.style.position='absolute';
  scaledGroup.style.left='50%'; scaledGroup.style.top='50%';
  scaledGroup.style.width = getComputedStyle(document.documentElement).getPropertyValue('--plate-pct') || '72%';
  scaledGroup.style.height = getComputedStyle(document.documentElement).getPropertyValue('--plate-pct') || '72%';
  scaledGroup.style.transform = 'translate(-50%,-50%) scale(var(--overlay-baseline))';
  scaledGroup.style.transformOrigin = '50% 50%';

  // perfect circle svg (kept transparent - overlay scaling will affect element sizes)
  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox','0 0 100 100');
  svg.setAttribute('preserveAspectRatio','xMidYMid meet');
  svg.className = 'scaledSvg';
  svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0'; svg.style.width='100%'; svg.style.height='100%';
  const circle = document.createElementNS(svgNS,'circle');
  circle.setAttribute('cx','50'); circle.setAttribute('cy','50'); circle.setAttribute('r','49.5');
  circle.setAttribute('fill','transparent'); circle.setAttribute('stroke','transparent');
  svg.appendChild(circle);
  scaledGroup.appendChild(svg);

  // append on-plate items to scaledGroup using same pixel coordinates as base so they match visually; these scale with the group
  (payload.positions || []).forEach(p => {
    if (p.placement === 'side') return;
    const w = document.createElement('div');
    w.className = 'itemWrapper';
    w.style.position='absolute';
    w.style.left = (p.x||0) + 'px';
    w.style.top  = (p.y||0) + 'px';
    w.style.width = (p.sizePx||48) + 'px';
    w.style.height = (p.sizePx||48) + 'px';
    w.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    const img = document.createElement('img');
    img.src = (p._imgOverride || CATALOG_IMG[p.id] || ('images/' + (p.id || 'unknown') + '.svg'));
    img.alt = p.label || p.id || '';
    img.classList.remove('clip-half'); img.style.transform = '';
    const frac = p.fraction || 1;
    if (Math.abs(frac - 0.5) < 0.001) img.classList.add('clip-half');
    else if (frac < 0.5) img.style.transform = `scale(${Math.max(0.25, Math.min(1, frac))})`;
    w.appendChild(img);
    scaledGroup.appendChild(w);
  });

  scaledContainer.appendChild(scaledGroup);
  targetOverlay.appendChild(scaledContainer);
  targetOverlay._scaledGroup = scaledGroup;
  targetOverlay.style.display = 'block';
}

// compute total calories for a mapping id->grams (if mapping omitted, compute from payload)
function totalCaloriesFromMap(map){
  let sum = 0;
  Object.keys(map || {}).forEach(id => {
    const grams = map[id] || 0;
    const calPerG = CAL_PER_G[id] !== undefined ? CAL_PER_G[id] : 0.8;
    sum += grams * calPerG;
  });
  return sum;
}
function totalCaloriesPayloadFromPositions(positions){
  return (positions || []).reduce((s,p) => {
    const calPerG = CAL_PER_G[p.id] !== undefined ? CAL_PER_G[p.id] : 0.8;
    return s + (p.grams || 0) * calPerG;
  }, 0);
}
function totalCaloriesPayload(){
  // Prefer payload.totalCalories passed from index.html; fallback to computing from positions
  if (payload && typeof payload.totalCalories === 'number') return Math.max(0, Math.round(payload.totalCalories));
  return Math.max(0, Math.round(totalCaloriesPayloadFromPositions(payload.positions || [])));
}

// Draw annulus starting at the plate edge and extending outward for growth, inward for shrink
function drawAnnulus(annNode, scale){
  annNode.innerHTML = '';
  if (!scale || isNaN(scale)) return;
  const canvas = annNode.parentElement;
  const canvasRect = canvas.getBoundingClientRect();
  const platePct = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--plate-pct')) / 100;
  const baseDia = Math.min(canvasRect.width, canvasRect.height) * platePct;
  const scaledDia = baseDia * scale;

  // When scale > 1: annulus should start at plate edge and extend outward to scaledDia.
  // When scale < 1: annulus should start at scaledDia and end at plate edge (we draw a red ring inside).
  let ann = document.createElement('div');
  ann.className = 'annulus';

  if (scale >= 1) {
    // outer diameter equals scaledDia; inner diameter equals baseDia
    const outer = scaledDia;
    const thickness = Math.max(4, (scaledDia - baseDia) / 2);
    // to make inner edge coincide with base plate edge, set width to outer and border thickness to thickness
    ann.style.width = outer + 'px';
    ann.style.height = outer + 'px';
    ann.style.border = `${thickness}px solid limegreen`;
    ann.style.boxSizing = 'border-box';
    ann.style.opacity = 0.9;
  } else {
    // scale < 1: draw an inward red ring whose outer edge is baseDia and inner edge is scaledDia
    const outer = baseDia;
    const thickness = Math.max(4, (baseDia - scaledDia) / 2);
    ann.style.width = outer + 'px';
    ann.style.height = outer + 'px';
    // draw border that visually occupies the inward space by using border with negative offset via outline trick is not available,
    // but centering the border over the outer circle makes inner edge at scaled diameter when border thickness = (outer - scaled)/2
    ann.style.border = `${thickness}px solid tomato`;
    ann.style.boxSizing = 'border-box';
    ann.style.opacity = 0.95;
  }

  annNode.appendChild(ann);
}

// compute totals for targetMap; if targetMap omitted, use recommended mapping or prompt as needed
function computeScaleFromCalories(targetMap){
  const actualCal = Math.max(1, totalCaloriesPayload());
  const targetCal = Math.max(0, totalCaloriesFromMap(targetMap || {}));
  if (targetCal <= 0) return 0.001;
  return Math.max(0.12, Math.min(3.0, Math.sqrt(targetCal / actualCal)));
}

// run compare: build overlay, hide base on-plate items, draw annulus and set uniform scale on overlay group
function runCompare(targetOverlay, targetBase, annNode, captionEl, targetMap, title){
  if (!payload) { alert('No saved plate'); return; }
  captionEl.textContent = title || '';

  // clear previous
  targetOverlay.innerHTML = '';
  annNode.innerHTML = '';

  buildScaledOverlay(targetOverlay);

  const scale = computeScaleFromCalories(targetMap);

  // hide base on-plate items so only scaled overlay items show
  Array.from(targetBase.querySelectorAll('.itemWrapper')).forEach(el => {
    if (el.dataset.onplate === '1') el.classList.add('hidden-onplate');
  });

  // draw annulus that starts at plate edge
  drawAnnulus(annNode, scale);

  // apply uniform scale to scaledGroup (this scales plate overlay + on-plate items)
  const scaledGroup = targetOverlay._scaledGroup;
  if (scaledGroup) {
    scaledGroup.style.transition = 'transform 850ms cubic-bezier(.2,.9,.2,1)';
    requestAnimationFrame(()=> scaledGroup.style.transform = `translate(-50%,-50%) scale(${scale})`);
  }

  // caption: show calorie totals + diffs per item
  setTimeout(()=> {
    const actualCal = Math.round(totalCaloriesPayload());
    const targetCal = Math.round(totalCaloriesFromMap(targetMap || {}));
    const diffPct = targetCal === 0 ? (actualCal === 0 ? 0 : -100) : Math.round(((targetCal - actualCal) / Math.max(1, actualCal)) * 100);

    // simple per-id diff summary
    const agg = {};
    (payload.positions || []).forEach(p => { agg[p.id] = (agg[p.id]||0) + (p.grams || 0); });
    const diffs = [];
    const ids = new Set([...Object.keys(agg), ...Object.keys(targetMap || {})]);
    ids.forEach(id => {
      const a = agg[id] || 0; const t = (targetMap && (targetMap[id] || 0)) || 0;
      if (Math.abs(a - t) < 1) return;
      const pct = a === 0 ? (t>0?100:0) : Math.round(((t - a) / Math.max(1,a)) * 100);
      diffs.push(`${id}: ${Math.round(a)}g→${Math.round(t)}g (${pct>=0?'+':''}${pct}%)`);
    });
    captionEl.textContent = `${title? title + ': ' : ''} total kcal ${actualCal} → ${targetCal} (${diffPct>=0?'+':''}${diffPct}%); ${diffs.length? diffs.join('; '): 'No significant changes'}`;
  }, 900);
}

// clear compare: remove overlay, annulus, and show base on-plate items again
function clearCompare(targetOverlay, targetBase, annNode, captionEl){
  targetOverlay.innerHTML = '';
  delete targetOverlay._scaledGroup;
  annNode.innerHTML = '';
  Array.from(targetBase.querySelectorAll('.itemWrapper')).forEach(el => {
    if (el.dataset.onplate === '1') el.classList.remove('hidden-onplate');
  });
  captionEl.textContent = 'Comparison cleared. Template remains colored.';
}

// helper: recommended portions -> grams (used as default)
function portionsToGramsMap(portions){
  const g = {};
  Object.keys(portions||{}).forEach(id => {
    const per = (id in CAL_PER_G) ? 100 : 100;
    g[id] = (portions[id] || 0) * per;
  });
  return g;
}
const recommendedPortions = { carrot:2, apple:1, potato:1, bread_variant:0, sausage:1, milk:1, water:1 };
const recommendedGrams = portionsToGramsMap(recommendedPortions);

// UI wiring
document.getElementById('backBtn').addEventListener('click', ()=> history.back());
document.getElementById('resetAllBtn').addEventListener('click', ()=> {
  clearCompare(overRec, baseRec, annRec, capRec);
  clearCompare(overReal, baseReal, annReal, capReal);
});

document.getElementById('cmpRecommendedBtn').addEventListener('click', ()=> {
  runCompare(overRec, baseRec, annRec, capRec, recommendedGrams, 'Recommended (Finland) vs Estimate');
});
document.getElementById('clearRecommendedBtn').addEventListener('click', ()=> clearCompare(overRec, baseRec, annRec, capRec));

document.getElementById('cmpRealityBtn').addEventListener('click', ()=> {
  const raw = prompt('Enter target grams JSON mapping (e.g. { "potato": 200, "apple": 100 }) — leave empty to use recommended');
  let target = null;
  if (!raw) target = recommendedGrams;
  else {
    try { target = JSON.parse(raw); } catch(e){ alert('Invalid JSON'); return; }
  }
  runCompare(overReal, baseReal, annReal, capReal, target, 'Reality vs Estimate');
});
document.getElementById('clearRealityBtn').addEventListener('click', ()=> clearCompare(overReal, baseReal, annReal, capReal));

// init
(function init(){
  const p = loadPayload();
  if (!p) {
    baseRec.innerHTML = ''; baseReal.innerHTML = '';
    capRec.textContent = 'No saved plate found in sessionStorage under key: ' + SESSION_KEY;
    capReal.textContent = 'No saved plate found in sessionStorage under key: ' + SESSION_KEY;
    return;
  }
  payload = p;
  normalizePayload(payload);
  renderBase(baseRec);
  renderBase(baseReal);
})();
</script>
</body>
</html>
