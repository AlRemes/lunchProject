<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Compare Plate</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body{font-family:Arial;margin:14px;background:#f6f6f7}
  .topbar{display:flex;gap:12px;align-items:center;justify-content:center;margin-bottom:10px}
  .btn{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:#fff;cursor:pointer}
  #stage{position:relative;width:760px;height:520px;margin:6px auto;border-radius:8px;background:#fff;padding:16px;box-shadow:0 6px 22px rgba(0,0,0,0.08)}
  #plateWrapper{position:relative;width:420px;height:420px;margin:0 auto}
  #plateCanvas{position:relative;width:420px;height:420px;border-radius:50%;background:#fff6e6;border:8px solid #eee;overflow:visible}
  .baseItemWrapper{position:absolute; transform:translate(-50%,-50%); pointer-events:none;}
  .baseItemWrapper img{display:block;width:100%;height:100%;object-fit:contain}
  .overlayWrapper{position:absolute; transform:translate(-50%,-50%); pointer-events:none; transition: opacity 300ms ease}
  .overlayWrapper img{display:block;width:100%;height:100%;object-fit:contain; pointer-events:none}
  .clip-half { -webkit-clip-path: polygon(0 0, 100% 100%, 0 100%); clip-path: polygon(0 0, 100% 100%, 0 100%); }
  #caption{margin-top:12px;text-align:center;font-size:14px}
  #controls{width:760px;margin:10px auto;text-align:center}
  select{padding:6px}
  .small{font-size:13px;color:#444}
  .hidden{display:none}
</style>
</head>
<body>
  <div class="topbar">
    <button id="backBtn" class="btn">Back</button>
    <button id="cmpRecommendedBtn" class="btn">Compare to Recommended (Finland)</button>
    <button id="cmpRealityBtn" class="btn">Compare to Reality (custom)</button>
    <div id="status" class="small" style="margin-left:8px"></div>
  </div>

  <div id="stage">
    <div id="plateWrapper">
      <div id="plateCanvas"></div>
    </div>
    <div id="caption" class="small"></div>
  </div>

<script>
/*
 compare.html
 - reads session fallback from sessionStorage key 'plate_positions_fallback' (same as index.html writes)
 - anchor instances in payload.positions must include: id, grams, gramsPerPortion (optional), x, y, sizePx, rotationDeg, placement, sideSlot, fraction (optional)
 - overlay animation uses grams to compute scale: scale = sqrt(targetGramsPerAnchor / anchorGrams)
 - half fractions are displayed as diagonal clipped halves (CSS), quarter fractions are shown scaled down
*/

const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbxEpMGjGgkn8a7_RG0-fSyPj-IZny88ZChcqtQ_ks1ALOv0bxrKYTmLy8pSjx0A5euX5A/exec';
const PLATE_DIAMETER = 420; // canvas in pixels

function qs(name) { const u = new URL(location.href); return u.searchParams.get(name); }

let basePayload = null; // will hold session payload including positions
let overlayWrappers = []; // for cleanup

// minimal local catalog to resolve images and gramsPerPortion when needed (should match index.html)
const CATALOG = {
  potato: { img:'images/potato.svg', gramsPerPortion:150 },
  sausage: { img:'images/sausage.svg', gramsPerPortion:75 },
  carrot: { img:'images/carrot.svg', gramsPerPortion:75 },
  bread: { img:'images/slice-of-bread.svg', gramsPerPortion:40 },
  apple: { img:'images/apple.svg', gramsPerPortion:150 },
  water: { img:'images/glass-of-water.svg', gramsPerPortion:200 },
  milk: { img:'images/milk-carton.svg', gramsPerPortion:250 },
  // bread_variant images may be present in instance._imgOverride
};

// load base payload (from sessionStorage fallback or from server if sessionId provided)
async function loadBase() {
  const sid = qs('sessionId');
  if (sid) {
    try {
      // fetch session payload from server (server expected to return { payload: {...} })
      const res = await fetch(WEB_APP_URL + '?mode=session&sessionId=' + encodeURIComponent(sid));
      if (res.ok) {
        const json = await res.json().catch(()=>null);
        if (json && json.payload) basePayload = json.payload;
      }
    } catch(e){ console.warn('session fetch failed', e); }
  }
  if (!basePayload) {
    const fallback = sessionStorage.getItem('plate_positions_fallback');
    if (fallback) basePayload = JSON.parse(fallback);
  }
  if (!basePayload) {
    alert('No base session found. Please build a plate and click Compare from the build page.');
    return;
  }
  // normalize positions: ensure each anchor has gramsPerPortion & fraction fields
  (basePayload.positions || []).forEach(p => {
    if (!p.gramsPerPortion) {
      const cat = CATALOG[p.id] || {};
      p.gramsPerPortion = p.gramsPerPortion || cat.gramsPerPortion || 100;
    }
    if (!('fraction' in p)) {
      p.fraction = (p.grams && p.gramsPerPortion) ? Math.round((p.grams / p.gramsPerPortion) * 100) / 100 : 1;
    }
    // some instances created by bread variant use id 'bread_variant' but have _imgOverride in payload; keep as is
  });
  renderBasePlate(basePayload);
}

// render anchored base plate: show base items (normal color)
function renderBasePlate(payload) {
  const canvas = document.getElementById('plateCanvas');
  canvas.innerHTML = '';
  const positions = payload.positions || [];
  positions.forEach((p, idx) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'baseItemWrapper';
    wrapper.style.left = (p.x || 0) + 'px';
    wrapper.style.top = (p.y || 0) + 'px';
    wrapper.style.width = (p.sizePx || 48) + 'px';
    wrapper.style.height = (p.sizePx || 48) + 'px';
    wrapper.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    // pick image from instance override or catalog
    const img = document.createElement('img');
    img.src = (p._imgOverride || (CATALOG[p.id] && CATALOG[p.id].img) || ('images/' + (p.id || 'unknown') + '.svg'));
    img.alt = p.label || p.id || '';
    // visual: if fraction is 0.5, show clipped half on base too (base view shows actual saved portion)
    if (Math.abs((p.fraction||1) - 0.5) < 0.001) {
      img.classList.add('clip-half');
    } else if ((p.fraction||1) < 0.5) {
      // quarter/smaller: scale the inner img
      const scale = Math.max(0.25, Math.min(1, p.fraction));
      img.style.transform = `scale(${scale})`;
    }
    wrapper.appendChild(img);
    canvas.appendChild(wrapper);
  });
}

// create overlay wrappers (one per anchor) for animation; returns array of { wrapper, anchor }
function createOverlayWrappers() {
  const canvas = document.getElementById('plateCanvas');
  // remove any previous overlays
  overlayWrappers.forEach(o => { if (o.wrapper && o.wrapper.parentNode) o.wrapper.parentNode.removeChild(o.wrapper); });
  overlayWrappers = [];
  const positions = basePayload.positions || [];
  positions.forEach((p, idx) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'overlayWrapper';
    wrapper.style.left = (p.x || 0) + 'px';
    wrapper.style.top = (p.y || 0) + 'px';
    wrapper.style.width = (p.sizePx || 48) + 'px';
    wrapper.style.height = (p.sizePx || 48) + 'px';
    wrapper.style.transform = `translate(-50%,-50%) rotate(${p.rotationDeg||0}deg)`;
    wrapper.style.opacity = '0';
    const img = document.createElement('img');
    img.src = (p._imgOverride || (CATALOG[p.id] && CATALOG[p.id].img) || ('images/' + (p.id || 'unknown') + '.svg'));
    img.alt = p.label || p.id || '';
    // start tiny so it can pop in; but for half we will apply clip and show full-size
    img.style.transform = 'scale(0.001)';
    img.style.transformOrigin = '50% 50%';
    wrapper.appendChild(img);
    canvas.appendChild(wrapper);
    overlayWrappers.push({ wrapper, img, anchor: p });
  });
  return overlayWrappers;
}

// animate comparison: targetMap is object id -> total target grams (not portions)
// If you have target portions, convert to grams before calling here.
// title is displayed in caption.
function animateComparison(targetMap, title, options = {}) {
  if (!basePayload || !basePayload.positions || basePayload.positions.length === 0) {
    alert('No base plate to compare. Build a plate first.');
    return;
  }
  const captionEl = document.getElementById('caption');
  captionEl.textContent = title || '';

  // Build anchor counts by id: gather anchors per id and their total grams
  const anchorsById = {};
  basePayload.positions.forEach(p => {
    anchorsById[p.id] = anchorsById[p.id] || [];
    anchorsById[p.id].push(p);
  });

  // Build target grams map per id (if targetMap contains portions convert externally)
  const targetGramsById = {};
  Object.keys(targetMap || {}).forEach(id => {
    targetGramsById[id] = targetMap[id] || 0;
  });

  // create overlay wrappers
  const overlays = createOverlayWrappers();

  // grayscale base plate (fade) just before animation
  const plateCanvas = document.getElementById('plateCanvas');
  plateCanvas.style.transition = 'filter 300ms ease, opacity 300ms ease';
  plateCanvas.style.filter = 'grayscale(1)';
  plateCanvas.style.opacity = '0.45';

  // compute per-anchor target grams: if there are N anchors for id, allocate target total grams evenly across anchors
  const anchorCountById = {};
  Object.keys(anchorsById).forEach(id => anchorCountById[id] = anchorsById[id].length);

  // animate overlays: for each overlay wrapper, compute anchorGrams and per-anchor targetGrams then scale
  const animateMs = options.animateMs || 900;
  requestAnimationFrame(() => {
    overlays.forEach(o => {
      const anchor = o.anchor;
      const anchorGrams = Math.max(1, anchor.grams || anchor.gramsPerPortion || (CATALOG[anchor.id] && CATALOG[anchor.id].gramsPerPortion) || 100);
      const targetTotalGrams = Math.max(0, targetGramsById[anchor.id] || 0);
      const countAnchors = anchorCountById[anchor.id] || 1;
      const perAnchorTarget = (countAnchors > 0) ? (targetTotalGrams / countAnchors) : 0;
      // compute scale factor via area ratio: scale = sqrt(target / anchor)
      let scale = 0.001;
      if (perAnchorTarget <= 0) {
        scale = 0.001; // effectively invisible
      } else {
        scale = Math.sqrt(Math.max(0.0001, perAnchorTarget / anchorGrams));
      }
      scale = Math.max(0.12, Math.min(3.0, scale));

      // Apply fraction visual rules for overlay element (mirror base's fraction but animate to target scale)
      const fraction = anchor.fraction || Math.round((anchor.grams / (anchor.gramsPerPortion || 1)) * 100) / 100;
      // For half anchors we want the overlay image clipped diagonally (top-left->bottom-right) and then scaled by the computed scale factor.
      // For quarter anchors we show a smaller scaled image.
      if (Math.abs(fraction - 0.5) < 0.001) {
        o.img.classList.add('clip-half');
        // animate from tiny clip to target (we don't change clip during animation)
        o.img.style.transform = `scale(${Math.max(0.6, Math.min(scale, 1.6))})`;
      } else if (fraction < 0.5) {
        o.img.classList.remove('clip-half');
        const innerScale = Math.max(0.25, Math.min(scale, 1.8));
        o.img.style.transform = `scale(${innerScale})`;
      } else {
        o.img.classList.remove('clip-half');
        o.img.style.transform = `scale(${Math.max(0.6, Math.min(scale, 1.8))})`;
      }
      o.wrapper.style.opacity = '1';
      // add transition to match animateMs
      o.img.style.transition = `transform ${animateMs}ms cubic-bezier(.2,.9,.2,1), opacity ${animateMs}ms ease`;
      // if perAnchorTarget is zero, fade out; else ensure visible
      o.wrapper.style.opacity = perAnchorTarget > 0 ? '1' : '0.0';
    });
  });

  // compute diffs and show summary after animation
  setTimeout(() => {
    const diffs = [];
    const anchorTotals = {};
    basePayload.positions.forEach(p => { anchorTotals[p.id] = (anchorTotals[p.id]||0) + (p.grams || p.gramsPerPortion || 0); });
    const allIds = new Set([...Object.keys(anchorTotals), ...Object.keys(targetGramsById)]);
    allIds.forEach(id => {
      const a = anchorTotals[id] || 0;
      const t = targetGramsById[id] || 0;
      if (Math.abs(a - t) < 1) return; // ignore tiny diffs
      const pct = a === 0 ? 100 : Math.round(((t - a) / a) * 100);
      diffs.push({ id, a, t, pct });
    });
    diffs.sort((x,y) => Math.abs(y.pct) - Math.abs(x.pct));
    const top = diffs.slice(0,6).map(d => `${d.id}: ${Math.round(d.a)}g→${Math.round(d.t)}g (${d.pct>0?'+':''}${d.pct}%)`);
    const captionEl = document.getElementById('caption');
    captionEl.textContent = (title ? title + ': ' : '') + (top.length ? top.join('; ') : 'No significant changes');

    // cleanup after show
    setTimeout(() => {
      // remove overlays
      overlayWrappers.forEach(o => { if (o.wrapper && o.wrapper.parentNode) o.wrapper.parentNode.removeChild(o.wrapper); });
      overlayWrappers = [];
      // restore base plate look
      plateCanvas.style.filter = '';
      plateCanvas.style.opacity = '';
      // done
    }, 2200);
  }, (options.animateMs || 900) + 120);
}

// Helper: convert a recommendedCounts in portions to grams by using CATALOG gramsPerPortion
function portionsToGramsMap(portionsMap) {
  const gramsMap = {};
  Object.keys(portionsMap || {}).forEach(id => {
    const gramsPer = (CATALOG[id] && CATALOG[id].gramsPerPortion) || 100;
    gramsMap[id] = (portionsMap[id] || 0) * gramsPer;
  });
  return gramsMap;
}

// Example recommendedCounts (Finland) — use same conservative mapping you chose in index.html
const recommendedCountsFinlandLunch_portions = {
  carrot: 2,
  apple: 1,
  potato: 1,
  bread: 0,
  sausage: 1,
  milk: 1,
  water: 1
};
const recommendedCountsFinlandLunch_grams = portionsToGramsMap(recommendedCountsFinlandLunch_portions);

// UI wiring
document.getElementById('backBtn').addEventListener('click', ()=> { history.back(); });
document.getElementById('cmpRecommendedBtn').addEventListener('click', ()=> {
  animateComparison(recommendedCountsFinlandLunch_grams, 'Recommended (Finland) vs Estimate', { animateMs: 900 });
});

// cmpRealityBtn remains generic: it expects you to pass target grams by id.
// For demonstration it prompts for a JSON mapping or falls back to recommended.
document.getElementById('cmpRealityBtn').addEventListener('click', ()=> {
  const raw = prompt('Enter target grams JSON mapping (e.g. { "potato": 200, "apple": 100 }) — leave empty to use recommended');
  let target = null;
  if (!raw) target = recommendedCountsFinlandLunch_grams;
  else {
    try { target = JSON.parse(raw); } catch(e) { alert('Invalid JSON'); return; }
  }
  animateComparison(target, 'Reality vs Estimate', { animateMs: 900 });
});

// load on open
loadBase();

</script>
</body>
</html>
